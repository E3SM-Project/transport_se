!#define _DBG_ print *,"file: ",__FILE__," line: ",__LINE__," ithr: ",hybrid%ithr
#define _DBG_ 
! Looks like 6 gives enough precision in general
! for very low res that might not be the case...
#define _GLLPTS_ 6

module surfaces_mod
  use kinds, only : real_kind
  use coordinate_systems_mod, only : cartesian3d_t, spherical_polar_t, change_coordinates
  use edge_mod, only : EdgeBuffer_t
  use dimensions_mod, only : nv

  implicit none

  private

  type, public :: ctrlvol_t

     real (kind=real_kind)    :: vol(nv,nv)          ! area of the unit sphere covered (local)
     real (kind=real_kind)    :: totvol(nv,nv)          ! area of the unit sphere covered (local)
     real (kind=real_kind)    :: invvol(nv,nv)       ! inverse area (includes neigbors)
     type (cartesian3D_t)     :: vert(4,nv,nv)       ! bounding box for the polygon
     type (spherical_polar_t) :: vert_latlon(4,nv,nv)       ! bounding box for the polygon
     integer                  :: nvert(nv,nv)               ! abs(nvert)=number of vertex per polygon: if nvert < 0 orientation is clockwise

  end type ctrlvol_t

  type (ctrlvol_t), public, allocatable, target  :: cvlist(:)
  type (EdgeBuffer_t), private  :: edge1


  ! User interface
  public :: InitControlVolumes1 ! allocates internal data structure
  public :: InitControlVolumes2 ! Inits all surfaces: vol,totvol, invvol
  public :: GetVolume
  public :: GetVolumeLocal
  public :: GetVertex
  public :: GetNumVertex

  ! Unit test:
  public :: VerifVolumes       
  logical, private :: initialized=.false.
contains

  ! Ok elemid is the local element id (in nets:nete)

  function GetVertex(vid,i,j,elemid) result(vtx)
    use parallel_mod, only : abortmp

    integer, intent(in) :: vid,i,j,elemid
    type (Cartesian3D_t), pointer :: vtx(:)

    if(.not. initialized) call abortmp('Attempt to use volumes prior to initializing')
    vtx => cvlist(elemid)%vert(:,i,j)

  end function GetVertex

  function GetNumVertex(i,j,elemid) result(nvert)
    use parallel_mod, only : abortmp

    integer, intent(in) :: i,j,elemid
    integer             :: nvert

    if(.not. initialized) call abortmp('Attempt to use volumes prior to initializing')
    if(.NOT.(MODULO(nv,2)==0)) then
       call abortmp("surfaces_mod GetNumVertex(): NV odd not implemented")
    endif
    nvert = cvlist(elemid)%nvert(i,j)

  end function GetNumVertex

  function GetVolume(elemid) result(vol)
    use parallel_mod, only : abortmp

    integer, intent(in) :: elemid
    real (kind=real_kind), dimension(:,:), pointer :: vol

    if(.not. initialized) call abortmp('Attempt to use volumes prior to initializing')
    vol => cvlist(elemid)%totvol    

  end function GetVolume

  function GetVolumeLocal(elemid) result(vol)
    use parallel_mod, only : abortmp

    integer, intent(in) :: elemid
    real (kind=real_kind), dimension(:,:), pointer :: vol

    if(.not. initialized) call abortmp('Attempt to use volumes prior to initializing')
    vol => cvlist(elemid)%vol    

  end function GetVolumeLocal
  subroutine InitControlVolumes1(nelemd)
    use edge_mod, only :   initedgebuffer
    integer, intent(in) :: nelemd
    ! Cannot be done in a threaded region
    allocate(cvlist(nelemd))
    call initedgebuffer(edge1,3)
  end subroutine InitControlVolumes1

  subroutine InitControlVolumes2(elem, hybrid,nets,nete)    
    use bndry_mod, only : bndry_exchangev
    use edge_mod, only : edgeVpack, edgeVunpack, edgeVunpackVert, freeedgebuffer
    use element_mod, only : element_t
    use hybrid_mod, only : hybrid_t
    use coordinate_systems_mod, only : cartesian2d_t, cubedsphere2cart
    use parallel_mod, only : abortmp

    use quadrature_mod, only : quadrature_t, gausslobatto
    use dimensions_mod, only : nlev

    integer,              intent(in)    :: nets,nete
    type (element_t),     intent(in), target    :: elem(:)
    type (hybrid_t),      intent(in) :: hybrid

    type (cartesian2d_t), pointer    :: cartv(:,:)
    real (kind=real_kind)            :: delx_k,dely_k,sum_dbg,r,xyz(3)
    integer                          :: i,j,ie,k,kptr,gllpts,dir,nvert,k2

    real (kind=real_kind)            :: test(nv,nv,nlev),vertpack(nv,nv,3)
    type (cartesian2d_t)             :: corner
    type (cartesian3D_t)             :: cart 
    type (quadrature_t)              :: gllsrf
    type (spherical_polar_t)         :: polar_tmp
    real (kind=real_kind)            :: rvert

    type (cartesian2d_t)             :: vert(4)
    logical                          :: Debug=.FALSE.


    ! consctruct GLL points used to compute surface area of control volume
    ! MT:  why dont we switch to analytic formula?
    gllpts = _GLLPTS_ ! this is the mid-point rule for volumes/surfaces
    if(gllpts.gt.1)then
       gllsrf = gausslobatto(gllpts)
    endif

#if 0
    gll = gausslobatto(nv)

    ! mid point rule:
    do i=1,nv-1
       gllnm1(i) = ( gll%points(i) + gll%pointsz(i+1) ) /2
    enddo

    ! for a nv x nv grid, comput the (nv-1) x (nv-1) grid which has cell
    ! areas equal to GLL weights
    gllnm1(1) = -1 + gll%weights(1)/2
    do i=2,nv-1
       gllnm1(i) = gllnm1(i-1) + gll%weights(i)
    enddo

    ! check that gll(i) < gllnm1(i) < gll(i+1)
    do i=1,nv-1
       if (gll%points(i) > gllnm1(i) .or. gllnm1(i) > gll%points(i+1)) then
          call abortmp("Error: CV and GLL points not interleaved") 
       endif
    enddo

    ! compute cubed-sphere coordinates of gllnm1 grid
    do ii=nets,nete
       call convert_gbl_index(elem(ii)%vertex%number,ie,je,face_no)
       start%x=-DD_PI/4 + ie*dx
       start%y=-DD_PI?4 + je*dy
       end%x  =start%x + dx
       end%y  =start%y + dy
       
       elem(ii)%dx=dx
       elem(ii)%dy=dy
       cartv_nm1(ii,:,:) = element_coordinates(start,end,gllnm1)
    enddo
#endif

    
    test(:,:,:) = 0_real_kind

    do ie=nets,nete
       cartv => elem(ie)%cartv(:,:)

       do j=1,nv
          do i=1,nv
             do k=1,4
                cvlist(ie)%vert(k,i,j)%x = 0_real_kind
                cvlist(ie)%vert(k,i,j)%y = 0_real_kind
                cvlist(ie)%vert(k,i,j)%z = 0_real_kind
             enddo
          enddo
       enddo

       ! interior

       do j=2,nv-1       
          do i=2,nv-1
             delx_k                = (cartv(i+1,j)%x-cartv(i-1,j)%x)*0.5_real_kind
             dely_k                = (cartv(i,j+1)%y-cartv(i,j-1)%y)*0.5_real_kind

             corner%x = (cartv(i-1,j-1)%x + cartv(i,j-1)%x + cartv(i-1,j)%x + cartv(i,j)%x)*0.25_real_kind
             corner%y = (cartv(i-1,j-1)%y + cartv(i,j-1)%y + cartv(i-1,j)%y + cartv(i,j)%y)*0.25_real_kind

             cvlist(ie)%vol(i,j) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

             ! internal vertex on Cubed sphere
             ! Here is the order:
             ! 
             ! 4NW <- 3NE
             !  |      ^
             !  v      |
             ! 1SW -> 2SE


             vert(1)%x = corner%x 
             vert(1)%y = corner%y 

             vert(2)%x = corner%x + delx_k
             vert(2)%y = corner%y 

             vert(3)%x = corner%x + delx_k
             vert(3)%y = corner%y + dely_k 

             vert(4)%x = corner%x
             vert(4)%y = corner%y + dely_k              

             do k=1,4
                xyz = cubedsphere2cart(vert(k),elem(ie)%FaceNum)
                cvlist(ie)%vert(k,i,j)%x = xyz(1)
                cvlist(ie)%vert(k,i,j)%y = xyz(2)
                cvlist(ie)%vert(k,i,j)%z = xyz(3)
             enddo
             cvlist(ie)%nvert(i,j) = 4

          end do
       enddo

       ! Compute everything on the edges and then sum

       do i=2,nv-1
          j=1
          delx_k                = (cartv(i+1,j)%x-cartv(i-1,j)%x)*0.5_real_kind
          dely_k                = (cartv(i,j+1)%y-cartv(i,  j)%y)*0.5_real_kind

          corner%x = (cartv(i-1,j)%x + cartv(i,j)%x)*0.5_real_kind
          corner%y = (cartv(i-1,j)%y + cartv(i,j)%y)*0.5_real_kind
          cvlist(ie)%vol(i,j) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

          cvlist(ie)%vert(4,i,j)%x = cvlist(ie)%vert(1,i,j+1)%x
          cvlist(ie)%vert(4,i,j)%y = cvlist(ie)%vert(1,i,j+1)%y
          cvlist(ie)%vert(4,i,j)%z = cvlist(ie)%vert(1,i,j+1)%z
          cvlist(ie)%vert(3,i,j)%x = cvlist(ie)%vert(2,i,j+1)%x
          cvlist(ie)%vert(3,i,j)%y = cvlist(ie)%vert(2,i,j+1)%y
          cvlist(ie)%vert(3,i,j)%z = cvlist(ie)%vert(2,i,j+1)%z

          j=nv
          delx_k                = (cartv(i+1,j)%x-cartv(i-1,j)%x)*0.5_real_kind
          dely_k                = (cartv(i,  j)%y-cartv(i,j-1)%y)*0.5_real_kind

          corner%x = (cartv(i-1,j-1)%x + cartv(i,j-1)%x + cartv(i-1,j)%x + cartv(i,j)%x)*0.25_real_kind
          corner%y = (cartv(i-1,j-1)%y + cartv(i,j-1)%y + cartv(i-1,j)%y + cartv(i,j)%y)*0.25_real_kind
          cvlist(ie)%vol(i,j) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

          cvlist(ie)%vert(1,i,j)%x = cvlist(ie)%vert(4,i,j-1)%x
          cvlist(ie)%vert(1,i,j)%y = cvlist(ie)%vert(4,i,j-1)%y
          cvlist(ie)%vert(1,i,j)%z = cvlist(ie)%vert(4,i,j-1)%z
          cvlist(ie)%vert(2,i,j)%x = cvlist(ie)%vert(3,i,j-1)%x
          cvlist(ie)%vert(2,i,j)%y = cvlist(ie)%vert(3,i,j-1)%y
          cvlist(ie)%vert(2,i,j)%z = cvlist(ie)%vert(3,i,j-1)%z

       enddo

       do j=2,nv-1
          i=1
          delx_k                = (cartv(i+1,j)%x-cartv(i,j  )%x)*0.5_real_kind
          dely_k                = (cartv(i,j+1)%y-cartv(i,j-1)%y)*0.5_real_kind

          corner%x = (cartv(i,j)%x + cartv(i,j-1)%x)*0.5_real_kind
          corner%y = (cartv(i,j)%y + cartv(i,j-1)%y)*0.5_real_kind
          cvlist(ie)%vol(i,j) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

          cvlist(ie)%vert(2,i,j)%x = cvlist(ie)%vert(1,i+1,j)%x
          cvlist(ie)%vert(2,i,j)%y = cvlist(ie)%vert(1,i+1,j)%y
          cvlist(ie)%vert(2,i,j)%z = cvlist(ie)%vert(1,i+1,j)%z
          cvlist(ie)%vert(3,i,j)%x = cvlist(ie)%vert(4,i+1,j)%x
          cvlist(ie)%vert(3,i,j)%y = cvlist(ie)%vert(4,i+1,j)%y
          cvlist(ie)%vert(3,i,j)%z = cvlist(ie)%vert(4,i+1,j)%z

          i=nv
          delx_k                = (cartv(i,j  )%x-cartv(i-1,j)%x)*0.5_real_kind
          dely_k                = (cartv(i,j+1)%y-cartv(i,j-1)%y)*0.5_real_kind

          corner%x = (cartv(i-1,j-1)%x + cartv(i,j-1)%x + cartv(i-1,j)%x + cartv(i,j)%x)*0.25_real_kind
          corner%y = (cartv(i-1,j-1)%y + cartv(i,j-1)%y + cartv(i-1,j)%y + cartv(i,j)%y)*0.25_real_kind
          cvlist(ie)%vol(i,j) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

          cvlist(ie)%vert(4,i,j)%x = cvlist(ie)%vert(3,i-1,j)%x
          cvlist(ie)%vert(4,i,j)%y = cvlist(ie)%vert(3,i-1,j)%y
          cvlist(ie)%vert(4,i,j)%z = cvlist(ie)%vert(3,i-1,j)%z
          cvlist(ie)%vert(1,i,j)%x = cvlist(ie)%vert(2,i-1,j)%x
          cvlist(ie)%vert(1,i,j)%y = cvlist(ie)%vert(2,i-1,j)%y
          cvlist(ie)%vert(1,i,j)%z = cvlist(ie)%vert(2,i-1,j)%z

       enddo

       ! Corners       

       ! SW
       delx_k = (cartv(2,1)%x-cartv(1,1)%x)*0.5_real_kind
       dely_k = (cartv(1,2)%y-cartv(1,1)%y)*0.5_real_kind

       corner%x = cartv(1,1)%x
       corner%y = cartv(1,1)%y
       cvlist(ie)%vol(1,1) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

       cvlist(ie)%vert(3,1,1)%x = cvlist(ie)%vert(1,2,2)%x
       cvlist(ie)%vert(3,1,1)%y = cvlist(ie)%vert(1,2,2)%y
       cvlist(ie)%vert(3,1,1)%z = cvlist(ie)%vert(1,2,2)%z

       ! SE
       delx_k                 = (cartv(nv,1)%x-cartv(nv-1,1)%x)*0.5_real_kind
       dely_k                 = (cartv(nv,2)%y-cartv(nv,  1)%y)*0.5_real_kind

       corner%x = (cartv(nv,1)%x +cartv(nv-1,1)%x)*0.5_real_kind
       corner%y = (cartv(nv,1)%y +cartv(nv-1,1)%y)*0.5_real_kind
       cvlist(ie)%vol(nv,1) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

       cvlist(ie)%vert(4,nv,1)%x = cvlist(ie)%vert(2,nv-1,2)%x
       cvlist(ie)%vert(4,nv,1)%y = cvlist(ie)%vert(2,nv-1,2)%y
       cvlist(ie)%vert(4,nv,1)%z = cvlist(ie)%vert(2,nv-1,2)%z

       ! NE
       delx_k                  = (cartv(nv,nv)%x-cartv(nv-1,nv)%x)*0.5_real_kind
       dely_k                  = (cartv(nv,nv)%y-cartv(nv,nv-1)%y)*0.5_real_kind

       corner%x = (cartv(nv-1,nv-1)%x+cartv(nv-1,nv)%x+cartv(nv,nv-1)%x+cartv(nv,nv)%x)*0.25_real_kind
       corner%y = (cartv(nv-1,nv-1)%y+cartv(nv-1,nv)%y+cartv(nv,nv-1)%y+cartv(nv,nv)%y)*0.25_real_kind
       cvlist(ie)%vol(nv,nv) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

       cvlist(ie)%vert(1,nv,nv)%x = cvlist(ie)%vert(3,nv-1,nv-1)%x
       cvlist(ie)%vert(1,nv,nv)%y = cvlist(ie)%vert(3,nv-1,nv-1)%y
       cvlist(ie)%vert(1,nv,nv)%z = cvlist(ie)%vert(3,nv-1,nv-1)%z

       ! NW
       delx_k                 = (cartv(2,nv)%x-cartv(1,nv  )%x)*0.5_real_kind
       dely_k                 = (cartv(1,nv)%y-cartv(1,nv-1)%y)*0.5_real_kind

       corner%x = (cartv(1,nv)%x+cartv(1,nv-1)%x)*0.5_real_kind
       corner%y = (cartv(1,nv)%y+cartv(1,nv-1)%y)*0.5_real_kind
       cvlist(ie)%vol(1,nv) = IntegrateSurfEdges(delx_k,dely_k,corner,gllsrf,gllpts)

       cvlist(ie)%vert(2,1,nv)%x = cvlist(ie)%vert(4,2,nv-1)%x
       cvlist(ie)%vert(2,1,nv)%y = cvlist(ie)%vert(4,2,nv-1)%y
       cvlist(ie)%vert(2,1,nv)%z = cvlist(ie)%vert(4,2,nv-1)%z

       if(Debug)print *,"ELEMENT:",ie," -> ",cvlist(ie)%vol(:,:)

       kptr=0
       test(:,:,1) = cvlist(ie)%vol(:,:)
       call edgeVpack(edge1,test(1,1,1),1,kptr,elem(ie)%desc)

       cvlist(ie)%invvol(:,:) = cvlist(ie)%vol(:,:)

    enddo
    _DBG_
    call bndry_exchangeV(hybrid,edge1)
    _DBG_

    do ie=nets,nete
       kptr=0
       call edgeVunpack(edge1, cvlist(ie)%invvol(1,1),1, kptr, elem(ie)%desc)
       cvlist(ie)%totvol(:,:)=cvlist(ie)%invvol(:,:)
       cvlist(ie)%invvol(:,:)=1.0_real_kind/cvlist(ie)%invvol(:,:)
    enddo

    ! Create the polygon at the edges of the element


    if(.NOT.(MODULO(nv,2)==0)) then
       !call abortmp("surfaces_mod: NV odd not implemented")
       ! MT: moved abortmp() into GetNumVertex() routine
       ! so code will still run with NV odd, unless a surface package
       ! calls GetNumVertex()
    else

    do ie=nets,nete
       ! Special messed up copy
       ! 
       !ASC should be replaced by a edgepack
       ! S+N
       do i=1,nv/2
          j=1
          vertpack(i,j,1) = cvlist(ie)%vert(3,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(3,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(3,i,j)%z
          j=nv
          vertpack(i,j,1) = cvlist(ie)%vert(2,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(2,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(2,i,j)%z
       enddo

       do i=nv/2+1,nv
          j=1
          vertpack(i,j,1) = cvlist(ie)%vert(4,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(4,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(4,i,j)%z
          j=nv
          vertpack(i,j,1) = cvlist(ie)%vert(1,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(1,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(1,i,j)%z
       enddo

       ! E+W
       do j=2,nv/2
          i=1
          vertpack(i,j,1) = cvlist(ie)%vert(3,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(3,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(3,i,j)%z
          i=nv
          vertpack(i,j,1) = cvlist(ie)%vert(4,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(4,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(4,i,j)%z
       enddo

       do j=nv/2+1,nv-1
          i=1
          vertpack(i,j,1) = cvlist(ie)%vert(2,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(2,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(2,i,j)%z
          i=nv
          vertpack(i,j,1) = cvlist(ie)%vert(1,i,j)%x
          vertpack(i,j,2) = cvlist(ie)%vert(1,i,j)%y
          vertpack(i,j,3) = cvlist(ie)%vert(1,i,j)%z
       enddo

       do j=2,nv-1
          do i=2,nv-1
             vertpack(i,j,1) =0_real_kind
             vertpack(i,j,2) =0_real_kind
             vertpack(i,j,3) =0_real_kind
          enddo
       enddo

       kptr=0
       call edgeVpack(edge1,vertpack,3,kptr,elem(ie)%desc)

    enddo

    call bndry_exchangeV(hybrid,edge1)

    do ie=nets,nete

       kptr=0
       call edgeVunpackVert(edge1, cvlist(ie)%vert,elem(ie)%desc)       


       ! Count and orient vert array
       ! nvert is an integer: -4,-3,3,4
       ! Positive: 1->2->3->4 is counter clockwise on the sphere
       ! Negative: clockwise orientation

       do j=1,nv
          do i=1,nv
             nvert=0
             do k=1,4
                rvert = cvlist(ie)%vert(k,i,j)%x**2+cvlist(ie)%vert(k,i,j)%y**2+cvlist(ie)%vert(k,i,j)%z**2
                if(rvert>0.9_real_kind)nvert=nvert+1
             enddo
             if(.NOT.Orientation(cvlist(ie)%vert(:,i,j),elem(ie)%FaceNum))nvert=-nvert
             cvlist(ie)%nvert(i,j) = nvert
          enddo
       enddo
    enddo
    endif  ! NV even

    ! Release memory
    if(hybrid%masterthread) then
       call freeedgebuffer(edge1)
    end if

    deallocate(gllsrf%points)
    deallocate(gllsrf%weights)

    ! compute output needed for SCRIP:  lat/lon coordinates, and for the 
    ! control volume with only 3 corners, repeat the last point to make a 
    ! degenerate quad.  
    do ie=nets,nete
       do j=1,nv
          do i=1,nv
             do k=1,4
                rvert = cvlist(ie)%vert(k,i,j)%x**2+cvlist(ie)%vert(k,i,j)%y**2+cvlist(ie)%vert(k,i,j)%z**2
                if(rvert>0.9) then
                   cvlist(ie)%vert_latlon(k,i,j) = change_coordinates(cvlist(ie)%vert(k,i,j))
                else
                   ! pick either neighbor to make a degenerate quad
                   k2=k+1
                   if (k==4) k2=1
                   cvlist(ie)%vert_latlon(k,i,j) = change_coordinates(cvlist(ie)%vert(k2,i,j))
                endif
             enddo
! intent is to change orientation to make them all contour clockwise, but it does opposite
!             if (cvlist(ie)%nvert(i,j)<0) then
!                ! change orientation
!                ! 1,2,3,4 -> 1,4,3,2
!                polar_tmp = cvlist(ie)%vert_latlon(2,i,j)
!                cvlist(ie)%vert_latlon(2,i,j)=cvlist(ie)%vert_latlon(4,i,j)
!                cvlist(ie)%vert_latlon(4,i,j) = polar_tmp  
!             endif
          enddo
       enddo
    enddo
    
    initialized=.true.
  end subroutine InitControlVolumes2

  subroutine VerifVolumes(elem, hybrid,nets,nete)
    use reduction_mod, only : red_sum, psum_mt
    use hybrid_mod, only : hybrid_t
    use physical_constants, only : DD_PI
    use element_mod, only : element_t
    use parallel_mod, only : abortmp
    type(element_t), intent(in) :: elem(:)
    integer,              intent(in) :: nets,nete
    type (hybrid_t),      intent(in) :: hybrid

    real (kind=real_kind)            :: loc_sum(6),psum,ptot,Vol_tmp(1),corr
    real (kind=real_kind)            :: vol(nv,nv,nets:nete)
    integer                          :: i,j,ie,kptr,face

    real (kind=real_kind), dimension(:,:), pointer :: locvol

    if(.not. initialized) call abortmp('Attempt to use volumes prior to initializing')
    loc_sum = 0_real_kind

    do ie=nets,nete       
       face = elem(ie)%FaceNum
       locvol => GetVolumeLocal(ie)
       do j=1,nv
          do i=1,nv
             loc_sum(face) = loc_sum(face) + locvol(i,j)
          enddo
       enddo
    enddo

    ptot=0_real_kind
    _DBG_
    do face=1,6
       Vol_tmp(1)=loc_sum(face)
       call psum_mt(red_sum,Vol_tmp,1,hybrid)
       psum = red_sum%buf(1)

       ptot = ptot + psum

       if(hybrid%par%masterproc .and. hybrid%ithr==0) then 
          print *,face," : SURFACE FV = ",6_real_kind*psum/(4_real_kind * DD_PI)
          print *
       endif
    enddo
    _DBG_

    if(hybrid%par%masterproc .and. hybrid%ithr==0) then 
       print *,"SURFACE FV = ", ptot/(4_real_kind * DD_PI)
       print *
    endif


100 format (A13,1(E24.15))

  end subroutine VerifVolumes

  !   ^
  !   |dy  o
  !   |
  ! (x,y) ---->dx
  function  IntegrateSurfEdges(dx,dy,corner,gll,npts) result(integral)
    use coordinate_systems_mod, only : cartesian2d_t
    use quadrature_mod, only : quadrature_t

    integer, intent(in)   :: npts
    type (quadrature_t)   :: gll
    type (cartesian2d_t)  :: corner
    real (kind=real_kind) :: dx,dy,da,integral,x,y

    integer               :: i,j

    integral = 0_real_kind
    da       = dx*dy*0.25_real_kind

    if(npts == 1)then ! mid-point rule

       ! Surface integral

       x = corner%x + 0.5_real_kind*dx
       y = corner%y + 0.5_real_kind*dy
       integral = dx*dy*sqrtmetdet(x,y)

    else ! GLL quadrature

       ! Surface integral

       do j=1,npts
          do i=1,npts
             x             = corner%x + 0.5_real_kind*(1.0_real_kind + gll%points(i))*dx
             y             = corner%y + 0.5_real_kind*(1.0_real_kind + gll%points(j))*dy
             integral      = integral + sqrtmetdet(x,y)*gll%weights(i)*gll%weights(j)*da
          enddo
       enddo

    endif

  end function IntegrateSurfEdges

  function Orientation(v,FaceNum) result(orient)

    type (cartesian3d_t)  :: v(3)
    integer               :: FaceNum
    type (cartesian3D_t)  :: v12,v23
    real (kind=real_kind) :: test,cart(3,3)

    logical               :: orient

    orient=.FALSE.

    if ((FaceNum == 5).OR.(FaceNum == 6)) then

       cart(1,1) = v(1)%x
       cart(2,1) = v(1)%y
       cart(3,1) = v(1)%z

       cart(1,2) = v(2)%x
       cart(2,2) = v(2)%y
       cart(3,2) = v(2)%z

       cart(1,3) = v(3)%x
       cart(2,3) = v(3)%y
       cart(3,3) = v(3)%z

       v12%x = cart(1,2) - cart(1,1)
       v12%y = cart(2,2) - cart(2,1)
       v12%z = cart(3,2) - cart(3,1)

       v23%x = cart(1,3) - cart(1,2)
       v23%y = cart(2,3) - cart(2,2)
       v23%z = cart(3,3) - cart(3,2)

       test = (v12%y*v23%z - v12%z*v23%y)*v12%x &
            - (v12%x*v23%z - v12%z*v23%x)*v12%y &
            + (v12%x*v23%y - v12%y*v23%x)*v12%z

       if (test > 0_real_kind)then
          orient=.TRUE.
       endif

    else
       orient=.TRUE.
    endif

  end function Orientation

  function sqrtmetdet(x1,x2) result(metdet)

    real (kind=real_kind),intent(in) :: x1,x2
    real (kind=real_kind) :: r
    real (kind=real_kind) :: metdet

    r=SQRT(1.0_real_kind + TAN(x1)**2 + TAN(x2)**2)        
    metdet  = 1_real_kind/((r**3)*(COS(x1)**2)*(COS(x2)**2))

  end function sqrtmetdet

end module surfaces_mod
