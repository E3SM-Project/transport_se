#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

module advance_mod

  use kinds, only : real_kind
  use dimensions_mod, only : np
  ! semi-implicit needs to be re-initialized each time dt changes 
  real (kind=real_kind) :: initialized_for_dt   = 0
  real (kind=real_kind), public :: It(np,np), H_local4(np*np,4)
  logical :: It_set = .false.
contains
  subroutine advance_init(Hcheck)
    use dimensions_mod, only : nlev, np
    use control_mod, only :  test_case
    use shallow_water_mod, only : kmass_swirl

    implicit none
    real(kind=real_kind), intent(IN) :: Hcheck(np,np)
    real(kind=real_kind), parameter :: cc=0.447213595499958

    integer i,j,k
    real(kind=real_kind) :: xgrid(16), ygrid(16), func(16)

    It=Hcheck
    It_set=.true.


!    Hcheck_local=matmul(Hcheck, transpose(Hcheck))
    It=Hcheck
!OG
!now forming matrix H for optim filter
! don't forget to call this limiter for the initial data!!!

      xgrid(1)=-1.0; xgrid(2)=-cc; xgrid(3)=cc;  xgrid(4)=1.0; 
      xgrid(5)=-1.0; xgrid(6)=-cc; xgrid(7)=cc;  xgrid(8)=1.0; 
      xgrid(9)=-1.0; xgrid(10)=-cc; xgrid(11)=cc;  xgrid(12)=1.0; 
      xgrid(13)=-1.0; xgrid(14)=-cc; xgrid(15)=cc;  xgrid(16)=1.0; 
      ygrid(1:4)=-1.0; ygrid(5:8)=-cc; ygrid(9:12)=cc; ygrid(13:16)=1.0;


      do i=1,16
	do j=1,4

          if(j==1)then
            do k=1,16
	       func(k)=1.0D0
	    enddo
          endif
          if(j==2)then
            do k=1,16
	       func(k)=xgrid(k)
	    enddo
          endif
          if(j==3)then
            do k=1,16
	       func(k)=ygrid(k)
	    enddo
          endif
          if(j==4)then
            do k=1,16
	       func(k)=xgrid(k)*ygrid(k)
	    enddo
          endif

          H_local4(i,j)=func(i)
	enddo
      enddo

  end subroutine advance_init



#ifdef _NONSTAGGER
  subroutine advance_nonstag( elem, edge2,  edge3,  deriv,  flt,   hybrid,  &
       dt,  pmean,     tl,   nets,   nete)

    ! ---------------------
    use kinds, only : real_kind
    ! ---------------------
    use physical_constants, only : rearth 
    ! ---------------------
    use dimensions_mod, only : nv, np, nlev
    ! ---------------------
    use element_mod, only : element_t
    ! ---------------------
    use edge_mod, only : EdgeBuffer_t, edgevpack, edgevunpack
    ! ---------------------
    use filter_mod, only : filter_t, filter_P, filter_V
    ! ---------------------
    use hybrid_mod, only : hybrid_t
    ! ---------------------
    use reduction_mod, only : reductionbuffer_ordered_1d_t
    ! ---------------------
    use derivative_mod, only : derivative_t, gradient_sphere, divergence_sphere,vorticity_sphere,&
         divergence_sphere_wk
    ! ---------------------
    use time_mod, only : timelevel_t, smooth
    ! ---------------------
    use control_mod, only :  filter_freq, filter_counter, topology, test_case, LFTfreq
    ! ---------------------
    use shallow_water_mod, only : tc1_velocity, vortex_velocity, swirl_velocity
    ! ---------------------
    use cg_mod, only : cg_t
    ! ---------------------
    use bndry_mod, only : bndry_exchangev
    use viscosity_mod, only : neighbor_minmax
    ! ---------------------
    !  FOR DEBUGING use only 
    ! ---------------------
    !    use schedule_mod
    use global_norms_mod
    ! ---------------------
    use perf_mod, only : t_startf, t_stopf ! _EXTERNAL


    implicit none

    type (element_t)     , intent(inout), target :: elem(:)
    type (EdgeBuffer_t)  , intent(in) :: edge2
    type (EdgeBuffer_t)  , intent(inout) :: edge3

    type (derivative_t)  , intent(in) :: deriv

    type (filter_t)                   :: flt
    type (hybrid_t)      , intent(in) :: hybrid

    real (kind=real_kind), intent(in) :: dt
    real (kind=real_kind), intent(in) :: pmean
    type (TimeLevel_t)   , intent(in) :: tl
    integer              , intent(in) :: nets
    integer              , intent(in) :: nete
    integer               :: ig

    ! =================
    ! Local
    ! =================
    ! Thread private working set ...
    real (kind=real_kind), dimension(:,:), pointer     :: rspheremv,spheremv
    real (kind=real_kind), dimension(nv,nv,2,nlev,nets:nete)  :: vtens
    real (kind=real_kind), dimension(np,np,nlev,nets:nete) :: ptens
    logical :: do_leapfrog


    real (kind=real_kind) :: dt2, real_time

    real*8                :: st,et
    integer    :: i,j,k,ie
    integer    :: kptr
    integer    :: nm1,n0,np1
    integer    :: nstep

    nm1   = tl%nm1
    n0    = tl%n0
    np1   = tl%np1
    nstep = tl%nstep

    dt2 = 2.0d0*dt

    real_time = dt*real(nstep,kind=real_kind)

    call t_startf('advance_nonstag')


#define USE_LEAPFROG

! for testing only:
#undef USE_MATSUNO
#undef USE_RK2
#undef USE_RK2M


#ifdef USE_LEAPFROG
    ! LFTfreq=0   pure Leapfrog (default)
    ! LFTfreq=1   pure Leapfrog-trapazoidal
    ! LFTfreq=n   alternate Leapfrog, leapfrog-trapazoidal
    do_leapfrog=.true.
    if (LFTfreq>0) do_leapfrog = (mod(nstep,LFTfreq).ne.0)

    ! for now, dont use LF-trapazoidal during bootstrap (nstep=0) phase
    ! maybe it is ok -need to check
    if (nstep==0) do_leapfrog=.true.

    if (do_leapfrog) then

       ! Leapfrog timestep: u(np1) = u(nm1) + dt2*DSS [ RHS(u(n0)) ]
       call compute_and_apply_rhs(np1,nm1,n0,dt2,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)

       ! ====================================================
       ! apply viscosity  
       ! ====================================================
       call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,np1,nets,nete,dt2)
    else

       ! leapfrog+trapazoidal
       ! 2x as expensive as LF, but 2nd order, no Robert filter needed, 
       ! dt sqrt(2) larger than LF
       ! u(*) = u(n-1) + 2dt F(u(n))   u(*) is at time level n+1
       ! u(n+1) = u(n) + dt [ F(u(n)) + F(u(*)) ] /2
       
       ! u(n+1) = u(n) + dt/2 F(u(n))          
       call compute_and_apply_rhs(np1,n0,n0,dt/2,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
       
       ! u(n-1) = u(n-1) + 4( u(n+1)-u(n))     u(*) above
       do ie=nets,nete
          elem(ie)%state%v(:,:,:,:,nm1)  = elem(ie)%state%v(:,:,:,:,nm1) + &
               4*(elem(ie)%state%v(:,:,:,:,np1)-elem(ie)%state%v(:,:,:,:,n0)  )
          elem(ie)%state%p(:,:,:,nm1)  = elem(ie)%state%p(:,:,:,nm1) + &
               4*(elem(ie)%state%p(:,:,:,np1)-elem(ie)%state%p(:,:,:,n0)  )
       enddo
       
       ! u(n+1) = u(n+1) + dt/2 F(u(*))        
       call compute_and_apply_rhs(np1,np1,nm1,dt/2,real_time+dt,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
       ! ====================================================
       ! apply viscosity  Note: use dt, not dt/2
       ! ====================================================
       call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,np1,nets,nete,dt)
    endif
#endif       


#ifdef USE_MATSUNO
    ! first order:
    !  u* = u + a*dt*f(u)  
    !  u  = u + dt*f(u*)
    ! Matsuno  a=1.0
    !  a=.75  1.0  same stability as Leapfrog, more accurate than Matsuno
    !  a=.5   standard RK2 (but stability is .8 leapfrog)
    !       call compute_and_apply_rhs(np1,n0,n0,dt,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
    call compute_and_apply_rhs(np1,n0,n0,dt,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
    call compute_and_apply_rhs(np1,n0,np1,dt,real_time+dt,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
!   call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,np1,nets,nete,dt)
    if (smooth/=0) stop 'ERROR: smooth>0 not allowed'
#endif

#ifdef USE_RK2
    ! RK2 with forward euler
    ! Foward Euler  t u(n0) -> t+1 u(np1)
    call compute_and_apply_rhs(np1,n0,n0,dt,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
    ! Foward Euler  t+1 u(np1) -> t+2 u(np1)
    call compute_and_apply_rhs(np1,np1,np1,dt,real_time+dt,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)

!    u(np1) = (u(np1) +  u(n0) )/2
    do ie=nets,nete
       elem(ie)%state%v(:,:,:,:,np1)  = (elem(ie)%state%v(:,:,:,:,np1) + &
            elem(ie)%state%v(:,:,:,:,n0)) /2 
       elem(ie)%state%p(:,:,:,np1)  = (elem(ie)%state%p(:,:,:,np1) + &
            elem(ie)%state%p(:,:,:,n0)) /2 
    enddo
!   call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,np1,nets,nete,dt)
    if (smooth/=0) stop 'ERROR: smooth>0 not allowed'
#endif

#ifdef USE_RK2M
    ! RK2 with matsuno instead of forward euler
    ! matsuno from t u(n0) to t+1 u(np1)
    call compute_and_apply_rhs(np1,n0,n0,dt,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
    call compute_and_apply_rhs(np1,n0,np1,dt,real_time+dt,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)

    ! matsuno from t+1 u(np1) to t+2 u(nm1)
    call compute_and_apply_rhs(nm1,np1,np1,dt,real_time+dt,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
    call compute_and_apply_rhs(nm1,np1,nm1,dt,real_time+2*dt,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)

!    u(np1) = (u(n0) +  u(nm1) )/2
    do ie=nets,nete
       elem(ie)%state%v(:,:,:,:,np1)  = (elem(ie)%state%v(:,:,:,:,nm1) + &
            elem(ie)%state%v(:,:,:,:,n0)) /2 
       elem(ie)%state%p(:,:,:,np1)  = (elem(ie)%state%p(:,:,:,nm1) + &
            elem(ie)%state%p(:,:,:,n0)) /2 
    enddo
!   call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,np1,nets,nete,dt)
    if (smooth/=0) stop 'ERROR: smooth>0 not allowed'
#endif




    if (smooth/=0) then
    do ie=nets,nete
       ! ====================================================
       ! apply Robert filter
       ! ====================================================
       do k=1,nlev
          do j=1,nv
             do i=1,nv
                elem(ie)%state%v(i,j,1,k,n0)  = elem(ie)%state%v(i,j,1,k,n0) + smooth*(elem(ie)%state%v(i,j,1,k,nm1) &
                     - 2.0D0*elem(ie)%state%v(i,j,1,k,n0) + elem(ie)%state%v(i,j,1,k,np1))
                elem(ie)%state%v(i,j,2,k,n0)  = elem(ie)%state%v(i,j,2,k,n0) + smooth*(elem(ie)%state%v(i,j,2,k,nm1) &
                     - 2.0D0*elem(ie)%state%v(i,j,2,k,n0) + elem(ie)%state%v(i,j,2,k,np1))
                elem(ie)%state%p(i,j,k,n0)  = elem(ie)%state%p(i,j,k,n0) + smooth*(elem(ie)%state%p(i,j,k,nm1) &
                     - 2.0D0*elem(ie)%state%p(i,j,k,n0) + elem(ie)%state%p(i,j,k,np1))
             end do
          end do
       end do
    end do
    endif

    call t_stopf('advance_nonstag')

    !$OMP BARRIER
  end subroutine advance_nonstag

!--------------------------------------------------------------------------------------------

  subroutine advance_nonstag_rk( MyRk, elem, edge2,  edge3,  deriv,  flt,   hybrid,  &
       dt,  pmean,     tl,   nets,   nete)

    ! ---------------------
    use kinds, only : real_kind
    ! ---------------------
    use physical_constants, only : rearth 
    ! ---------------------
    use dimensions_mod, only : nv, np, nlev
    ! ---------------------
    use element_mod, only : element_t
    ! ---------------------
    use edge_mod, only : EdgeBuffer_t, edgevpack, edgevunpack
    ! ---------------------
    use filter_mod, only : filter_t, filter_P, filter_V
    ! ---------------------
    use hybrid_mod, only : hybrid_t
    ! ---------------------
    use reduction_mod, only : reductionbuffer_ordered_1d_t, parallelsum
    ! ---------------------
    use derivative_mod, only : derivative_t, gradient_sphere, divergence_sphere,vorticity_sphere,&
         divergence_sphere_wk
    ! ---------------------
    use time_mod, only : timelevel_t, smooth
    ! ---------------------
    use control_mod, only :  filter_freq, filter_counter, topology, test_case, sub_case, &
          limiter_option, nu, nu_s, tracer_advection_formulation, TRACERADV_UGRADQ, kmass
    ! ---------------------
    use shallow_water_mod, only : tc1_velocity, vortex_velocity, vortex_exact, swirl_velocity
    ! ---------------------
    use cg_mod, only : cg_t
    ! ---------------------
    use bndry_mod, only : bndry_exchangev
    use viscosity_mod, only : neighbor_minmax, local_minmax, biharmonic_wk
    ! ---------------------
    !  FOR DEBUGING use only 
    ! ---------------------
    !    use schedule_mod
    use global_norms_mod
    ! ---------------------
    use types_mod, only : rk_t


    implicit none

    type (element_t)     , intent(inout), target :: elem(:)
    type (Rk_t)          , intent(in) :: MyRk
    type (EdgeBuffer_t)  , intent(in) :: edge2
    type (EdgeBuffer_t)  , intent(inout) :: edge3

    type (derivative_t)  , intent(in) :: deriv

    type (filter_t)                   :: flt
    type (hybrid_t)      , intent(in) :: hybrid

    real (kind=real_kind), intent(in) :: dt
    real (kind=real_kind), intent(in) :: pmean
    type (TimeLevel_t)   , intent(inout) :: tl
    integer              , intent(in) :: nets
    integer              , intent(in) :: nete
    integer                           :: ig

    ! =================
    ! Local
    ! =================

    ! pointer ...

    real (kind=real_kind), dimension(:,:), pointer     :: fcor,rspheremv,spheremv,metdet,rmetdetp
    real (kind=real_kind), dimension(:,:,:,:), pointer :: met,metinv

    ! Thread private working set ...

    real (kind=real_kind), dimension(nv,nv,2,nlev,nets:nete) :: vtens
    real (kind=real_kind), dimension(np,np,nlev,nets:nete)   :: ptens

    real (kind=real_kind), dimension(np,np,nlev)   :: p_storage, ptens_tvd

    real (kind=real_kind), dimension(nv,nv,2)    :: grade   ! kinetic energy gradient
    real (kind=real_kind), dimension(nv,nv,2)    :: gradh   ! grad(h)

    real (kind=real_kind), dimension(nv,nv,2)    :: pv      ! p*v lat-lon
    real (kind=real_kind), dimension(nv,nv)      :: E          ! kinetic energy term
    real (kind=real_kind), dimension(nv,nv)      :: zeta       ! relative vorticity
    real (kind=real_kind), dimension(nv,nv)      :: div, div_storage
    real (kind=real_kind), dimension(nv,nv,2)    :: ulatlon


    real (kind=real_kind) :: v1,v2
    real (kind=real_kind) :: vtens1,vtens2
    real (kind=real_kind) :: pmin(nlev,nets:nete),pmax(nlev,nets:nete)
    real (kind=real_kind) :: pvarmin(nlev,nets:nete),pvarmax(nlev,nets:nete)
    real (kind=real_kind) :: plmin(nv,nv,nlev,nets:nete),plmax(nv,nv,nlev,nets:nete)


    real (kind=real_kind) :: delta,real_time

    real*8     :: st,et,dtstage
    integer    :: i,j,k,s,ie
    integer    :: kptr
    integer    :: nm1,n0,np1
    integer    :: nstep
    integer    :: ntmp

    logical :: Debug = .FALSE.

    integer    :: k1, k2
    real (kind=real_kind) :: p_unwrapped1(np*np,1),p_unwrapped2(np*np,1), p_unwrapped3(np*np,1),&
       Kmat(np*np,np*np)
    real (kind=real_kind) :: Dmat(np*np,np*np), W(np*np,np*np), Winv(np*np,np*np)
    real (kind=real_kind) :: p_plus(np*np),p_minus(np*np),q_plus(np*np),&
       q_minus(np*np),r_plus(np*np),r_minus(np*np)
    real (kind=real_kind) :: Fmat(np*np,np*np), Fmatstar(np*np,np*np)
    real (kind=real_kind) :: umin, umax

    real (kind=real_kind) ::  notreliable(nets:nete),notreliable_sum


!temporary code
    real (kind=real_kind) ::  modal_coefs(np,np), dummy1, eps, smoothness


    if (test_case=="swtc1" .or. test_case=="vortex" .or. test_case=="swirl") then
       ! advection test cases support conservation form or advective form
    else
       ! shallow water test cases require conservation form of h equation
       if (tracer_advection_formulation==TRACERADV_UGRADQ) then
          print *,'ERROR: shallow water tests require conservation formulation:'
          stop '(tracer_advection_formulation=1)'
       endif   
    endif

    nm1   = tl%nm1
    n0    = tl%n0
    np1   = tl%np1
    nstep = tl%nstep

    ! hyperviscosity can be applied in 3 different ways:
    ! 1. added to the RHS within each RK stage ( 1 extra DSS per stage)
    ! 2. time-split after each RK stage (2 extra DSS per stage)
    ! 3. time-split after complete RK step ( 2 extra DSS per step)
#define HYPERVIS_T1
#undef HYPERVIS_T2
#undef HYPERVIS_T3


    ! We want to make this leap-frog compliant
    ! Copy u^n to u^n+1
    do ie=nets,nete
       do k=1,nlev
          do j=1,nv
             do i=1,nv
                elem(ie)%state%v(i,j,1,k,np1)  = elem(ie)%state%v(i,j,1,k,n0)
                elem(ie)%state%v(i,j,2,k,np1)  = elem(ie)%state%v(i,j,2,k,n0)
                elem(ie)%state%p(i,j,k, np1)   = elem(ie)%state%p(i,j,k,n0)
             end do
          end do
       end do
    enddo

    real_time = dt*real(nstep,kind=real_kind)


!    write(6,*)'REAL TIME', real_time

    do s=1,MyRk%Stages
       dtstage = dt*(MyRk%beta(s)/MyRk%alpha(s))

       if(debug)then
          if(hybrid%par%masterproc) print *,"Performing stage ", s
       endif
       ! ===================================
       ! find min/max of p over all neighbors
       ! ===================================


!if we limit q field, not (\rho q)
!then first get q fields.
!get their neighb min/max values,
!and then get (\rho q) fields back

!THE CODE BELOW IS NOT OPTIMAL
!IF WE DO NOT HAVE LIMITING THERE IS NO REASON TO DIVIDE
!
       if(kmass.ne.-1)then
	  do ie=nets,nete
	      do k=1,nlev
		if(k.ne.kmass)then
		  elem(ie)%state%p(:,:,k,n0)=elem(ie)%state%p(:,:,k,n0)/&
                                             elem(ie)%state%p(:,:,kmass,n0)
                endif
	      enddo
	  enddo
       endif

!group of lim3 limiters, redistribution
       if ( (limiter_option == 3 ).or.( limiter_option == 31 )) then
          call neighbor_minmax(elem,hybrid,edge3,nets,nete,n0,pmin,pmax)
       endif

!group optimal based on iteration
       if (( limiter_option == 8 ).or.(limiter_option == 81 ) &
    .or.(limiter_option == 9) .or.(limiter_option == 91).or.(limiter_option == 92)) then
#if 1
          call neighbor_minmax(elem,hybrid,edge3,nets,nete,n0,pmin,pmax)
#else
          call neighbor_minmax(elem,hybrid,edge3,nets,nete,n0,pmin,pmax,pvarmin,pvarmax)
!          print *

          do k=1,3
!             write(*,'(i3,a,2e12.5)') k,' smoothness  max/min over domain: ',&
!             maxval(pvarmax(k,:)/(1e-12+pvarmin(k,:))),&
!             minval(pvarmax(k,:)/(1e-12+pvarmin(k,:)))

             do ie=nets,nete
                if ( (pvarmax(k,ie)/(1e-12+pvarmin(k,ie)))  < 60 ) then
!                   pmin(k,ie)=pmin(k,ie)-10.0
!                   pmax(k,ie)=pmax(k,ie)+10.0
                endif
             enddo
          enddo
#endif
       endif


!go back to old (\rho q) fields
       if(kmass.ne.-1)then
	  do ie=nets,nete
	      do k=1,nlev
		if(k.ne.kmass)then
		  elem(ie)%state%p(:,:,k,n0)=elem(ie)%state%p(:,:,k,n0)*&
                                             elem(ie)%state%p(:,:,kmass,n0)
                endif
	      enddo
	  enddo
       endif

!group of kuzmin's limiters
!these are not affected by if we have const mass field though Zalesak
!limiters are only made for div-free cases and flux form!
!i have no idea what to do with these in more general cases right now
!anyway they are way too dissipative to take them seriously

       if ((limiter_option == 21).or.(limiter_option == 20)) then
          call neighbor_minmax(elem,hybrid,edge3,nets,nete,n0,pmin,pmax)
       endif



       if(Debug) print *,'homme: adv.._rk 1'


       ! ===================================
       ! construct v tendencies and v.grad(p)
       ! on the velocity grid...
       ! ===================================

#ifdef HYPERVIS_T1
       ! compute weak biharmonic operator.  has mass matrix built in,
       ! but to fit into structure below, remove it for now:

!lim 10 is no visc, no limiter. i keep it this way for my own
!lim 20 and 21 are way too dissipative anyway, 
!so, they won't need visc
       if ((limiter_option .ne. 10).and.(limiter_option .ne. 20).and.(limiter_option .ne. 21)) then

!applying viscosity to q field
 	  if(kmass.ne.-1)then
	  do ie=nets,nete
	      do k=1,nlev
		if(k.ne.kmass)then
		  elem(ie)%state%p(:,:,k,n0)=elem(ie)%state%p(:,:,k,n0)/&
                                             elem(ie)%state%p(:,:,kmass,n0)
                endif
	      enddo
	  enddo
 	  endif

	  call biharmonic_wk(elem,ptens,vtens,deriv,edge3,hybrid,n0,nets,nete)

	  do ie=nets,nete
	      spheremv     => elem(ie)%spheremv
	      do k=1,nlev
		ptens(:,:,k,ie) =  -nu_s*ptens(:,:,k,ie)/spheremv(:,:)
		vtens(:,:,1,k,ie) = -nu*vtens(:,:,1,k,ie)/spheremv(:,:)
		vtens(:,:,2,k,ie) = -nu*vtens(:,:,2,k,ie)/spheremv(:,:)
	      enddo
	  enddo

	  if(kmass.ne.-1)then
!we do not apply viscosity to mass field
	  ptens(:,:,kmass,:)=0.0d0
	  do ie=nets,nete
	      do k=1,nlev
		if(k.ne.kmass)then
		  elem(ie)%state%p(:,:,k,n0)=elem(ie)%state%p(:,:,k,n0)*&
                                             elem(ie)%state%p(:,:,kmass,n0)
                endif
	      enddo
	  enddo
	  endif


       else
          ptens=0
          vtens=0
       endif
#else
       ptens=0
       vtens=0
#endif

       do ie=nets,nete
          met    => elem(ie)%met
          metinv => elem(ie)%metinv
          metdet => elem(ie)%metdet
          rmetdetp => elem(ie)%rmetdetp
          fcor   => elem(ie)%fcor
          spheremv     => elem(ie)%spheremv

          call set_prescribed_velocity(elem(ie),n0,real_time)

          do k=1,nlev
             ! ==============================================
             ! Compute kinetic energy term
             ! ==============================================
             do j=1,nv
                do i=1,nv

                   v1     = elem(ie)%state%v(i,j,1,k,n0)   ! contra
                   v2     = elem(ie)%state%v(i,j,2,k,n0)   ! contra 
                   ulatlon(i,j,1)=elem(ie)%D(1,1,i,j)*v1 + elem(ie)%D(1,2,i,j)*v2   ! contra->latlon
                   ulatlon(i,j,2)=elem(ie)%D(2,1,i,j)*v1 + elem(ie)%D(2,2,i,j)*v2   ! contra->latlon

                   E(i,j) = 0.5D0*(ulatlon(i,j,1)**2 + ulatlon(i,j,2)**2)  +&
                        elem(ie)%state%p(i,j,k,n0) + elem(ie)%state%ps(i,j)

                   pv(i,j,1) = ulatlon(i,j,1)*(pmean+elem(ie)%state%p(i,j,k,n0))
                   pv(i,j,2) = ulatlon(i,j,2)*(pmean+elem(ie)%state%p(i,j,k,n0))
                end do
             end do
             grade = gradient_sphere(E,deriv,elem(ie))       ! scalar -> latlon vector
             zeta = vorticity_sphere(ulatlon,deriv,elem(ie)) ! latlon vector -> scalar 
             if (tracer_advection_formulation==TRACERADV_UGRADQ) then
                gradh = gradient_sphere(elem(ie)%state%p(:,:,k,n0),deriv,elem(ie))
                div = ulatlon(:,:,1)*gradh(:,:,1)+ulatlon(:,:,2)*gradh(:,:,2)
             else
                div = divergence_sphere(pv,deriv,elem(ie))      ! latlon vector -> scalar

             endif

             ! ==============================================
             ! Compute velocity tendency terms
             ! ==============================================
             ! accumulate all RHS terms
             vtens(:,:,1,k,ie)=vtens(:,:,1,k,ie) + (ulatlon(:,:,2)*(fcor(:,:) + zeta(:,:))  - grade(:,:,1))
             vtens(:,:,2,k,ie)=vtens(:,:,2,k,ie) + (-ulatlon(:,:,1)*(fcor(:,:) + zeta(:,:)) - grade(:,:,2))
             ptens(:,:,k,ie) = ptens(:,:,k,ie) - div(:,:)

             ! take the local element timestep
             vtens(:,:,:,k,ie)=ulatlon(:,:,:) + dtstage*vtens(:,:,:,k,ie)
             ptens(:,:,k,ie) = elem(ie)%state%p(:,:,k,n0) + dtstage*ptens(:,:,k,ie)


!LIMITERS 20, 21, ETC, unfortunately, cannot wrap them into a routine
!------------------------------------------------------------------------------
             if ((limiter_option == 20).or.(limiter_option == 21)) then
!note that THESE LIMS ARE NO GOOD FOR TRACER_TOTAL_DIVERGENCE
!MOREOVER THEY WOULD SHOW WORSE RESULTS IF KMASS NE -1
!BUT REALLY THEY SHOULD BE RUN ONLY WITH TRACER_UGRADQ

!we need to build K and D only once
                if(k==1)then
		    p_storage=elem(ie)%state%p(:,:,:,n0)
		    div_storage=div!div is not really used below? so no need to store it?
		    do k1=1,np*np
			elem(ie)%state%p(:,:,:,n0)=0.0d0
			k2=0
			do i=1,np
			    do j=1,np
			      k2=k2+1
			      if(k2==k1)then
				  elem(ie)%state%p(i,j,k,n0)=1.0d0
			      endif
			    enddo
			enddo
			do j=1,nv
			    do i=1,nv
			      v1     = elem(ie)%state%v(i,j,1,k,n0)   ! contra
			      v2     = elem(ie)%state%v(i,j,2,k,n0)   ! contra 
			      ulatlon(i,j,1)=elem(ie)%D(1,1,i,j)*v1 + elem(ie)%D(1,2,i,j)*v2
			      ulatlon(i,j,2)=elem(ie)%D(2,1,i,j)*v1 + elem(ie)%D(2,2,i,j)*v2
			      pv(i,j,1) = ulatlon(i,j,1)*(pmean+elem(ie)%state%p(i,j,k,n0))
			      pv(i,j,2) = ulatlon(i,j,2)*(pmean+elem(ie)%state%p(i,j,k,n0))
			    end do
			end do


			if (tracer_advection_formulation==TRACERADV_UGRADQ) then
			  gradh = gradient_sphere(elem(ie)%state%p(:,:,k,n0),deriv,elem(ie))
			  div = ulatlon(:,:,1)*gradh(:,:,1)+ulatlon(:,:,2)*gradh(:,:,2)
			else
			  div = divergence_sphere(pv,deriv,elem(ie))      ! latlon vector -> scalar 
			endif

			k2=0
			do i=1,np
			  do j=1,np
			    k2=k2+1
			    Kmat(k1,k2)=-div(i,j)
			  enddo
			enddo
		    enddo
    !restore the field, we are done constructing matrix K
		    elem(ie)%state%p(:,:,:,n0)=p_storage
		    div=div_storage
		    W=0.0d0; Winv=0.0d0
		    k2=0
		    do i=1,np
			do j=1,np
			  k2=k2+1
			  W(k2,k2)=elem(ie)%spheremv(i,j)
			  Winv(k2,k2)=1.0/elem(ie)%spheremv(i,j)
		      enddo
		    enddo
    !i initially did it wrong, so, i need to transpose
		    Kmat=transpose(Kmat)  

		    Kmat=matmul(W,Kmat)
		    Dmat(:,:)=0.0d0          
		    do i=1,np*np
		      do j=i+1,np*np
			  Dmat(i,j)=max(0.0d0, -Kmat(i,j), -Kmat(j,i))
			  Dmat(j,i)=Dmat(i,j)
		      enddo
		    enddo
		    do i=1,np*np
			do j=1,i-1
			  Dmat(i,i)=Dmat(i,i)-Dmat(i,j)
			enddo
			do j=i+1,np*np
			  Dmat(i,i)=Dmat(i,i)-Dmat(i,j)
			enddo
		    enddo
		    Kmat=matmul(Winv,Kmat)
		    Dmat=matmul(Winv,Dmat)
                endif

		k2=0
		do i=1,np
		    do j=1,np
		      k2=k2+1
		      p_unwrapped1(k2,1)=p_storage(i,j,k)
		    enddo
		enddo 

!so we built K only for 1st level
!truly TVD
		if (( limiter_option == 20).or.(limiter_option == 9)) then
		    p_unwrapped2=p_unwrapped1+dtstage*matmul(Kmat+Dmat,p_unwrapped1)
		endif
!Zalesak
		if (( limiter_option == 21)) then
		    p_unwrapped3=p_unwrapped1+dtstage*matmul(Kmat+Dmat,p_unwrapped1)
		    Fmat=0.0d0
		    do i=1,np*np
			do j=1,np*np
			  if(i.ne.j)then
			    Fmat(i,j)=(-Dmat(i,j))*(p_unwrapped1(j,1)-p_unwrapped1(i,1))*dtstage
			  endif
			enddo
		    enddo
		    Fmatstar(:,:)=0.0
		    p_minus(:)=0.0d0; p_plus(:)=0.0d0; q_minus(:)=0.0d0; q_plus(:)=0.0d0

		    umin=pmin(k,ie); umax=pmax(k,ie);
		    do i=1,np*np
		      q_plus(i)  = umax-p_unwrapped3(i,1)
		      q_minus(i) = umin-p_unwrapped3(i,1)
		      do j=1,np*np
			if((i.ne.j))then
			  p_plus(i)=p_plus(i)+max(0.0,Fmat(i,j))
			  p_minus(i)=p_minus(i)+min(0.0,Fmat(i,j))
			endif
		      enddo
		      if(p_plus(i).ne.0)then
			r_plus(i)=min(1.0,q_plus(i)/p_plus(i))
		      else
			r_plus(i)=0.0
		      endif
		      if(p_minus(i).ne.0)then
			r_minus(i)=min(1.0,q_minus(i)/p_minus(i))
		      else
			r_minus(i)=0.0
		      endif
		    enddo
		    do i=1,np*np
		      do j=i+1,np*np 
			if(i.ne.j)then
			  if(Fmat(i,j)>0)then
			    Fmatstar(i,j)=min(r_plus(i)*W(i,i),r_minus(j)*W(j,j))*Fmat(i,j)/W(i,i)
			  else
			    Fmatstar(i,j)=min(r_plus(j)*W(j,j),r_minus(i)*W(i,i))*Fmat(i,j)/W(i,i)
			  endif
			endif
			Fmatstar(j,i)=-W(i,i)*Fmatstar(i,j)/W(j,j)
		      enddo
		    enddo
		    do i=1,np*np
		      p_unwrapped2(i,1)=p_unwrapped3(i,1)+sum(Fmatstar(i,:))
		    enddo
		endif

		k2=0
		do i=1,np
		    do j=1,np
		      k2=k2+1
		      ptens_tvd(i,j,k)=p_unwrapped2(k2,1) 
		    enddo
		enddo
             endif
!END OF KUZMINS LIMITERS-------------------------------------------------------
          end do!end of loop over levels

!this is convenient to test limiters
! write(6,*)'ie', ie


          notreliable(ie)=0.0
          if ( limiter_option == 3) then
             call limiter2d_minmax_lim3(ptens(:,:,:,ie),elem(ie)%spheremv,&
	       pmin(:,ie),pmax(:,ie),kmass)
	  endif

          if ( limiter_option == 31) then
             call limiter2d_minmax_lim31(ptens(:,:,:,ie),elem(ie)%spheremv,&
	       pmin(:,ie), kmass)
          endif 

          if ((limiter_option == 8))then
 	     call limiter_optim_iter_full(ptens(:,:,:,ie),elem(ie)%spheremv(:,:),&
               pmin(:,ie),pmax(:,ie), kmass,.true.,.true.,notreliable(ie))

!	     call limiter_optim_bilin(ptens(:,:,:,ie),1,kmass,elem(ie)%spheremv(:,:),&
!               .false.,pmin(:,ie),pmax(:,ie))

          endif

          if ((limiter_option == 81))then
 	     call limiter_optim_iter_full(ptens(:,:,:,ie),elem(ie)%spheremv(:,:),&
               pmin(:,ie),pmax(:,ie), kmass,.true.,.false.,notreliable(ie))
          endif

          if ( (limiter_option == 4) ) then
             call limiter2d_zero(ptens(:,:,:,ie),elem(ie)%spheremv, kmass)
          endif

          if (( limiter_option == 20).or.( limiter_option == 21))then
             ptens(:,:,:,ie)=ptens_tvd(:,:,:)
          endif


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1111
!!! limiters 9 and 91 to test selectiveness

!limiter 9 uses relaxed lim8 for smooth fields and lim8 as is for nonsmooth
!limiter 91 uses relaxed lim8 for smooth fields and bilinear for nonsmooth

          if ( (limiter_option == 9) ) then
            smoothness=0.15
            eps=0.1d0

	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,1,ie),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
 	    if(abs(dummy1)>smoothness)then
 	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),1,elem(ie)%spheremv(:,:),&
                pmin(:,ie),pmax(:,ie), kmass,.true.,.true.,notreliable(ie))
             else
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),1,elem(ie)%spheremv(:,:),&
               pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
             endif

	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,2,ie),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    if(abs(dummy1)>smoothness)then
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),2,elem(ie)%spheremv(:,:),&
               pmin(:,ie),pmax(:,ie), kmass,.true.,.true.,notreliable(ie))
             else
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),2,elem(ie)%spheremv(:,:),&
               pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
	    endif

	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,3,ie),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    if(abs(dummy1)>smoothness)then
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),3,elem(ie)%spheremv(:,:),&
               pmin(:,ie),pmax(:,ie), kmass,.true.,.true.,notreliable(ie))
            else
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),3,elem(ie)%spheremv(:,:),&
               pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
	    endif
!level 11 is C^\infty cyllinder made from gaussian

! 	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,11,ie),It))
! 	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
! 	    if(abs(dummy1)>smoothness)then
! 	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),11,elem(ie)%spheremv(:,:),&
!                pmin(:,ie),pmax(:,ie), kmass,.true.,.true.,notreliable(ie))
!             else
! 	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),11,elem(ie)%spheremv(:,:),&
!                pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
! 	    endif
          endif

          if ( (limiter_option == 91) ) then
            smoothness=0.15
            eps=0.1

	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,1,ie),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2

	    if(abs(dummy1)>smoothness)then
	     call limiter_optim_bilin(ptens(:,:,:,ie),1,kmass,elem(ie)%spheremv(:,:),&
               .false.,pmin(:,ie),pmax(:,ie))
            else
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),1,elem(ie)%spheremv(:,:),&
               pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
            endif

	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,2,ie),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    if(abs(dummy1)>smoothness)then
	     call limiter_optim_bilin(ptens(:,:,:,ie),2,kmass,elem(ie)%spheremv(:,:),&
               .false.,pmin(:,ie),pmax(:,ie))
             else
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),2,elem(ie)%spheremv(:,:),&
               pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
	    endif

	    modal_coefs=matmul(transpose(It),matmul(ptens(:,:,3,ie),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    if(abs(dummy1)>smoothness)then
	     call limiter_optim_bilin(ptens(:,:,:,ie),3,kmass,elem(ie)%spheremv(:,:),&
               .false.,pmin(:,ie),pmax(:,ie))
            else
	     call limiter_optim_iter_onelevel(ptens(:,:,:,ie),3,elem(ie)%spheremv(:,:),&
               pmin(:,ie)*(1-eps),pmax(:,ie)*(1+eps), kmass,.true.,.true.,notreliable(ie))
	    endif
          endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end of limiters 9


          do k=1,nlev
             ptens(:,:,k,ie) = ptens(:,:,k,ie)*elem(ie)%spheremv(:,:)
             vtens(:,:,1,k,ie) = vtens(:,:,1,k,ie)*elem(ie)%spheremv(:,:)
             vtens(:,:,2,k,ie) = vtens(:,:,2,k,ie)*elem(ie)%spheremv(:,:)
          enddo

          ! ===================================================
          ! Pack cube edges of tendencies, rotate velocities
          ! ===================================================
          kptr=0
          call edgeVpack(edge3, ptens(1,1,1,ie),nlev,kptr,elem(ie)%desc)
          kptr=nlev
          call edgeVpack(edge3,vtens(1,1,1,1,ie),2*nlev,kptr,elem(ie)%desc)

       end do

       if(Debug) print *,'homme: adv.._rk 2'

       !$OMP BARRIER
!       if(( limiter_option == 8).or.( limiter_option == 81))then
!          notreliable_sum=ParallelSum(notreliable,hybrid)
!       endif

!       if((hybrid%par%masterproc .and. hybrid%ithr==0).and.(notreliable_sum>0)) then 
!	  write (*,*) 'WARNING: optimal limiter might have failed,'
!	  write (*,*) 'either we are bouncing around roundoff, &
!	  or do not use lim8(or 81), \n or reduce timestep'
!       endif


       call bndry_exchangeV(hybrid,edge3)

       !$OMP BARRIER

       do ie=nets,nete

          rspheremv     => elem(ie)%rspheremv

          ! ===========================================================
          ! Unpack the edges for vgradp and vtens
          ! ===========================================================
          kptr=0
          call edgeVunpack(edge3, ptens(1,1,1,ie), nlev, kptr, elem(ie)%desc)

          kptr=nlev
          call edgeVunpack(edge3, vtens(1,1,1,1,ie), 2*nlev, kptr, elem(ie)%desc)

          ! ===========================================================
          ! Compute velocity and pressure tendencies for all levels
          ! ===========================================================
          do k=1,nlev
             do j=1,nv
                do i=1,nv
                   ptens(i,j,k,ie) = rspheremv(i,j)*ptens(i,j,k,ie)
                   vtens1=rspheremv(i,j)*vtens(i,j,1,k,ie)
                   vtens2=rspheremv(i,j)*vtens(i,j,2,k,ie)

                   ! lat-lon -> contra
                   vtens(i,j,1,k,ie) = elem(ie)%Dinv(1,1,i,j)*vtens1 + elem(ie)%Dinv(1,2,i,j)*vtens2
                   vtens(i,j,2,k,ie) = elem(ie)%Dinv(2,1,i,j)*vtens1 + elem(ie)%Dinv(2,2,i,j)*vtens2
                end do
             end do
          end do




          do k=1,nlev
             ! ====================================================
             ! Update
             ! ====================================================
             do j=1,nv
                do i=1,nv
                   elem(ie)%state%v(i,j,1,k,n0) = MyRk%alpha0(s)*elem(ie)%state%v(i,j,1,k,np1) &
                        + MyRk%alpha(s)*vtens(i,j,1,k,ie)
                   elem(ie)%state%v(i,j,2,k,n0) = MyRk%alpha0(s)*elem(ie)%state%v(i,j,2,k,np1) &
                        + MyRk%alpha(s)*vtens(i,j,2,k,ie)
                   elem(ie)%state%p(i,j,k,n0) = MyRk%alpha0(s)*elem(ie)%state%p(i,j,k,np1)+ &
                        MyRk%alpha(s)*ptens(i,j,k,ie)
                end do
             end do
          end do

!!!!!!!!!!this is only to test modal coefs
          if(nlev>9)then
	    modal_coefs=matmul(transpose(It),matmul(elem(ie)%state%p(:,:,1,n0),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    elem(ie)%state%p(:,:,8,n0)=dummy1


	    modal_coefs=matmul(transpose(It),matmul(elem(ie)%state%p(:,:,2,n0),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    elem(ie)%state%p(:,:,9,n0)=dummy1


	    modal_coefs=matmul(transpose(It),matmul(elem(ie)%state%p(:,:,3,n0),It))
	    dummy1=sum(modal_coefs(:,:)**2)-modal_coefs(1,1)**2
	    elem(ie)%state%p(:,:,10,n0)=dummy1
          endif
!!!!!!!!!!!

       end do
#ifdef HYPERVIS_T2
       call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,n0,&
            nets,nete,dtstage) 
#endif
       real_time =real_time + dtstage

!this is only for output reasons, if velocities are prescribed
      do ie=nets,nete
	  call set_prescribed_velocity(elem(ie),n0,real_time)
      enddo


    enddo ! stage loop

    ! ====================================================
    ! apply viscosity  
    ! ====================================================
#ifdef HYPERVIS_T3
    call advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,n0,&
         nets,nete,dt) 
#endif
    ! make leap-frog compliant
    ! after RK loop u^n containe u^{n+1} and u^{n+1} contains u^n
    ! thus we swap them
    ntmp    = tl%np1
    tl%np1  = tl%n0
    tl%n0   = ntmp

    !$OMP BARRIER
  end subroutine advance_nonstag_rk

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

  subroutine limiter_optim_bilin(ptens,lev,kmass,sphweights, outp, minp, maxp)

    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev
    use element_mod, only : element_t

    logical, intent(in) :: outp
    integer, intent(in) :: lev, kmass
    real (kind=real_kind), dimension(nlev), intent(in)   :: minp, maxp
    real (kind=real_kind), dimension(np,np,nlev), intent(inout)   :: ptens
    real (kind=real_kind), dimension(np,np), intent(in)   :: sphweights
    real (kind=real_kind), dimension(np,np)   :: weights,ptens_mass
    real (kind=real_kind), dimension(np,np)   :: tracer, modal_coefs

    real (kind=real_kind) :: sol(4), crval, H_tred(4,16),gridsol(16), H_red(16,4)
    real (kind=real_kind) :: const(4,33),bvec(33),w(2000), new_mass, dvec_loc(16,1),&
    D(16,16),D2(4,4),dvec(4,1)
    integer nact, iact(33), maxit, info, lw, iter(2,1), ierr, k1
    real (kind=real_kind) :: x(16,1), c(16), local_mass, x2(16,1)
    logical :: bigg

!not optimal code
    maxit=300
    lw=2000
!not optimal code
    weights=sphweights
    k=lev

    if(kmass.ne.-1)then   
	ptens_mass(:,:)=ptens(:,:,kmass)
	weights=weights*ptens_mass
	  if(k.ne.kmass)then
	    ptens(:,:,k)=ptens(:,:,k)/ptens_mass
	  endif
    endif


    H_red=H_local4(1:16,1:4)
    H_tred=TRANSPOSE(H_red)

    const(1:4,2:17)=H_tred
    const(1:4,18:33)=-H_tred

      tracer=ptens(:,:,k)
      modal_coefs=matmul(transpose(It),matmul(tracer,It))

      do i=2,17
	bvec(i)=minp(k)
	bvec(i+16)=-maxp(k)
      enddo

      local_mass = sum(tracer*weights)
      bigg=.true.



      k1=1
      do i=1,np
	do j=1,np
	    c(k1)=weights(i,j)
	    x(k1,1)=modal_coefs(i,j)
	    x2(k1,1)=tracer(i,j)
	    k1=k1+1
	enddo
      enddo

!      if((maxval(tracer)>maxp(k)).or.(minval(tracer)<minp(k))) bigg=.true.
    

      if((bigg))then

	k1=1
	do i=1,16
	    do j=1,16
	      if(i.NE.j)then
		D(i,j)=0.0
	      else
		D(i,i)=c(k1)
		k1=k1+1
	      endif
	    enddo
	enddo 

    !    dvec_loc=matmul(D,x2)
	dvec=matmul(H_tred,matmul(D,x2))
	D2=matmul(H_tred,matmul(D,H_red))


	info=0
	const(1:4,1)= matmul(H_tred,c)
	bvec(1)=local_mass
	call qpgen2(D2,dvec,4,4,sol,crval,const,bvec, 4, 33, 1, iact, nact, iter, w, info, maxit)

	gridsol=matmul(H_red,sol)
! 
! 	if(outp.AND.(local_mass>0.000001))then
! 	  write(6,*)'we optimized tracer?', info, '--------------------------', local_mass
! 	  new_mass=0.0D0
! 	  do k1=1,np*np
! 	      write(6,*) x2(k,1),'VeRSUS', gridsol(k1)
! 	      new_mass=new_mass+c(k1)*gridsol(k1)
! 	  enddo
! 	  write(6,*) local_mass,'VeRSUS masssssssssss', new_mass
! 	  write(6,*) 'min max are', minp, maxp
! 	endif


	if(info==0)then
	  k1=1
	  do i=1,np
	      do j=1,np
		ptens(i,j,k)=gridsol(k1)
		k1=k1+1
	      enddo
	  enddo
	else
  !lim 3 instead! this one always work
  !	    call limiter2d_max_onelevel(ptens(:,:,k),weights,maxp(k))
  !	    call limiter2d_min_onelevel(ptens(:,:,k),weights,minp(k))
	endif
      endif
   

    if(kmass.ne.-1)then   
	  if(k.ne.kmass)then
	    ptens(:,:,k)=ptens(:,:,k)*ptens_mass
	  endif
    endif

  end subroutine limiter_optim_bilin


!----------------------------------------------------------------------------
!----------------------------------------------------------------------------





  subroutine limiter_optim_iter_full(ptens,sphweights,minp,maxp,kmass,checkmin,checkmax, notreliable)

    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev
!    use element_mod, only : element_t

    logical, intent(in) :: checkmin,checkmax
    real (kind=real_kind), dimension(nlev), intent(in)   :: minp, maxp
    real (kind=real_kind), dimension(np,np,nlev), intent(inout)   :: ptens
    real (kind=real_kind), dimension(np,np), intent(in)   :: sphweights
    integer, intent(in) :: kmass
    real (kind=real_kind),  intent(out) :: notreliable
 
    real (kind=real_kind), dimension(np,np) :: weights
    real (kind=real_kind), dimension(np,np) :: ptens_mass
    integer  k1, k, i, j, iter
    logical :: whois_neg(np*np), whois_pos(np*np)
    real (kind=real_kind) :: addmass, weightssum, mass
    real (kind=real_kind) :: x(np*np),c(np*np)
    real (kind=real_kind), parameter :: tol=1e-13
    integer, parameter :: maxiter = 10

    weights=sphweights
    notreliable=0
 
    if(kmass.ne.-1)then   
	ptens_mass(:,:)=ptens(:,:,kmass)
	weights=weights*ptens_mass
	do k=1,nlev
	  if(k.ne.kmass)then
	    ptens(:,:,k)=ptens(:,:,k)/ptens_mass
	  endif
	enddo
    endif

    do k=1,nlev

      if(k.ne.kmass)then
!write(6,*)'starting', k
	k1=1
	do i=1,np
	  do j=1,np
	    c(k1)=weights(i,j)
	    x(k1)=ptens(i,j,k)
	    k1=k1+1
	  enddo
	enddo

        mass=sum(c*x)

!first, check if the problem has a solution
        if((mass-minp(k)*sum(c)<-tol).and.checkmin)then
           notreliable=1
!           return
        endif
        if((mass-maxp(k)*sum(c)>tol).and.checkmax)then
           notreliable=1
!           return
        endif



!write(6,*)'starting x', x
        iter=0
        do !iter=1,maxit
          iter=iter+1

!!!!!!!!!!!!!Temporary code
          if(iter>maxiter)then
	    notreliable=1.0
            exit
          endif

	  addmass=0.0d0

	  do k1=1,np*np
	    whois_neg(k1)=.true.
	    whois_pos(k1)=.true.
	    if((x(k1)>=maxp(k)).AND.(checkmax))then
	      addmass=addmass+(x(k1)-maxp(k))*c(k1)
	      x(k1)=maxp(k)
	      whois_pos(k1)=.false.
	    endif
	    if((x(k1)<=minp(k)).AND.(checkmin))then
	      addmass=addmass-(minp(k)-x(k1))*c(k1)
	      x(k1)=minp(k)
	      whois_neg(k1)=.false.
	    endif
	  enddo

!write(6,*)'iter, addmass', iter, addmass

!well if there is anything to fix we continue

!this is quite BAD IDEA
!on the one hand we'd like to avoid infinite loops 
!(who knows where the tol error would drive us)
!on the other, each time step in each element we potentially introduce 
!the relative error of 1e-13 which can accumulate

	  if(abs(addmass)>tol*abs(mass))then

	    weightssum=0.0d0
	    if(addmass>0)then
	      do k1=1,np*np
		if(whois_pos(k1))then
		  weightssum=weightssum+c(k1)
		endif
	      enddo
!write(6,*)'weightssum',weightssum
!write(6,*)'x before ',x
              if(weightssum>0.0)then
		do k1=1,np*np
		  if(whois_pos(k1))then
		    x(k1)=x(k1)+addmass/weightssum
		  endif
		enddo
              else
		notreliable=1
		exit
	      endif
            else
	      do k1=1,np*np
		if(whois_neg(k1))then
		  weightssum=weightssum+c(k1)
		endif
	      enddo
!write(6,*)'weightssum',weightssum
!write(6,*)'x before ',x
              if(weightssum>0.0)then
		do k1=1,np*np
		  if(whois_neg(k1))then
		    x(k1)=x(k1)+addmass/weightssum
		  endif
		enddo
              else
		notreliable=1
		exit
	      endif
            endif

!write(6,*)'x after ',x

	  else
            x=x+addmass/sum(c)
	    exit
	  endif

	enddo

	k1=1
	do i=1,np
	  do j=1,np
	    ptens(i,j,k)=x(k1)
	    k1=k1+1
	  enddo
	enddo


      endif
    enddo


    if(kmass.ne.-1)then   
	do k=1,nlev
	  if(k.ne.kmass)then
	    ptens(:,:,k)=ptens(:,:,k)*ptens_mass
	  endif
	enddo
    endif


  end subroutine limiter_optim_iter_full

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------


!this is to test selectiveness but this code duplicates whats above so we
!have to get rid of duplicatives later
  subroutine limiter_optim_iter_onelevel(ptens,lev,sphweights,minp,maxp,kmass,checkmin,checkmax, notreliable)

    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev
!    use element_mod, only : element_t

    logical, intent(in) :: checkmin,checkmax
    real (kind=real_kind), dimension(nlev), intent(in)   :: minp, maxp
    real (kind=real_kind), dimension(np,np,nlev), intent(inout)   :: ptens
    real (kind=real_kind), dimension(np,np), intent(in)   :: sphweights
    integer, intent(in) :: kmass, lev
    real (kind=real_kind),  intent(out) :: notreliable
 
    real (kind=real_kind), dimension(np,np) :: weights
    real (kind=real_kind), dimension(np,np) :: ptens_mass
    integer  k1, k, i, j, iter
    logical :: whois_neg(np*np), whois_pos(np*np)
    real (kind=real_kind) :: addmass, weightssum, mass
    real (kind=real_kind) :: x(np*np),c(np*np)
    real (kind=real_kind), parameter :: tol=1e-13
    integer, parameter :: maxiter = 10

    weights=sphweights
    notreliable=0
 
    if(kmass.ne.-1)then   
	ptens_mass(:,:)=ptens(:,:,kmass)
	weights=weights*ptens_mass
	  if(lev.ne.kmass)then
	    ptens(:,:,lev)=ptens(:,:,lev)/ptens_mass
	  endif
    endif

    do k=lev,lev

      if(k.ne.kmass)then
!write(6,*)'starting', k
	k1=1
	do i=1,np
	  do j=1,np
	    c(k1)=weights(i,j)
	    x(k1)=ptens(i,j,k)
	    k1=k1+1
	  enddo
	enddo

        mass=sum(c*x)

!first, check if the problem has a solution
        if((mass-minp(k)*sum(c)<-tol).and.checkmin)then
           notreliable=1
!           return
        endif
        if((mass-maxp(k)*sum(c)>tol).and.checkmax)then
           notreliable=1
!           return
        endif



!write(6,*)'starting x', x
        iter=0
        do !iter=1,maxit
          iter=iter+1

!!!!!!!!!!!!!Temporary code
          if(iter>maxiter)then
	    notreliable=1.0
            exit
          endif

	  addmass=0.0d0

	  do k1=1,np*np
	    whois_neg(k1)=.true.
	    whois_pos(k1)=.true.
	    if((x(k1)>=maxp(k)).AND.(checkmax))then
	      addmass=addmass+(x(k1)-maxp(k))*c(k1)
	      x(k1)=maxp(k)
	      whois_pos(k1)=.false.
	    endif
	    if((x(k1)<=minp(k)).AND.(checkmin))then
	      addmass=addmass-(minp(k)-x(k1))*c(k1)
	      x(k1)=minp(k)
	      whois_neg(k1)=.false.
	    endif
	  enddo

!write(6,*)'iter, addmass', iter, addmass

!well if there is anything to fix we continue

!this is quite BAD IDEA
!on the one hand we'd like to avoid infinite loops 
!(who knows where the tol error would drive us)
!on the other, each time step in each element we potentially introduce 
!the relative error of 1e-13 which can accumulate

	  if(abs(addmass)>tol*abs(mass))then

	    weightssum=0.0d0
	    if(addmass>0)then
	      do k1=1,np*np
		if(whois_pos(k1))then
		  weightssum=weightssum+c(k1)
		endif
	      enddo
!write(6,*)'weightssum',weightssum
!write(6,*)'x before ',x
	      do k1=1,np*np
		if(whois_pos(k1))then
		  x(k1)=x(k1)+addmass/weightssum
		endif
	      enddo
            else
	      do k1=1,np*np
		if(whois_neg(k1))then
		  weightssum=weightssum+c(k1)
		endif
	      enddo
!write(6,*)'weightssum',weightssum
!write(6,*)'x before ',x
	      do k1=1,np*np
		if(whois_neg(k1))then
		  x(k1)=x(k1)+addmass/weightssum
		endif
	      enddo
            endif

!write(6,*)'x after ',x

	  else
            x=x+addmass/sum(c)
	    exit
	  endif

	enddo

	k1=1
	do i=1,np
	  do j=1,np
	    ptens(i,j,k)=x(k1)
	    k1=k1+1
	  enddo
	enddo


      endif
    enddo


    if(kmass.ne.-1)then   
	if(k.ne.kmass)then
	    ptens(:,:,lev)=ptens(:,:,lev)*ptens_mass
	endif
    endif


  end subroutine limiter_optim_iter_onelevel

!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------

  subroutine limiter2d_minmax_lim3(Q,spheremv,qmin,qmax,kmass)
    !
    ! mass conserving limiter (2D only).  to be called just before DSS
    !
    ! in pure 2D advection, the element mass will not be negative before DSS
    ! this routine will redistribute to remove negative values (conservative)
    !
    ! if used in 3D, should be applied with 2D/vertical split advection
    ! 
    ! when advecting Qdp, ps should be at the same timelevel as Q
    ! When advecting Q, ps should be at one timelevel before Q
    !
    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev

    implicit none
    real (kind=real_kind), intent(inout)  :: Q(nv,nv,nlev)
    real (kind=real_kind), intent(in)  :: spheremv(nv,nv)
    real (kind=real_kind), intent(in)  :: qmin(nlev)
    real (kind=real_kind), intent(in)  :: qmax(nlev)
    integer, intent(in) :: kmass
    integer k


    if(kmass.ne.-1)then
      if((kmass<0).or.(kmass>nlev))then
        print *,'ERROR: index kmass is out of range in limiter2d_minmax_lim3'
        stop '(kmass is out of range, lim3)'
      else
	do k=1,nlev
	  if(k.ne.kmass)then
	    Q(:,:,k)=Q(:,:,k)/Q(:,:,kmass)
	    call limiter2d_max_onelevel(Q(:,:,k),spheremv(:,:)*Q(:,:,kmass),qmax(k))
	    call limiter2d_min_onelevel(Q(:,:,k),spheremv(:,:)*Q(:,:,kmass),qmin(k))
	    Q(:,:,k)=Q(:,:,k)*Q(:,:,kmass)
	  endif
	enddo
      endif
    else
      do k=1,nlev
	call limiter2d_max_onelevel(Q(:,:,k),spheremv(:,:),qmax(k))
	call limiter2d_min_onelevel(Q(:,:,k),spheremv(:,:),qmin(k))
      enddo
    endif

  end subroutine limiter2d_minmax_lim3


!-------------------------------------------------------------------------------

  subroutine limiter2d_minmax_lim31(Q,spheremv,qmin,kmass)
    !
    ! mass conserving limiter (2D only).  to be called just before DSS
    !
    ! in pure 2D advection, the element mass will not be negative before DSS
    ! this routine will redistribute to remove negative values (conservative)
    !
    ! if used in 3D, should be applied with 2D/vertical split advection
    ! 
    ! when advecting Qdp, ps should be at the same timelevel as Q
    ! When advecting Q, ps should be at one timelevel before Q
    !
    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev

    implicit none
    real (kind=real_kind), intent(inout)  :: Q(nv,nv,nlev)
    real (kind=real_kind), intent(in)  :: spheremv(nv,nv)
    real (kind=real_kind), intent(in)  :: qmin(nlev)
    integer, intent(in) :: kmass
    ! local
    integer k

    if(kmass.ne.-1)then
      if((kmass<0).or.(kmass>nlev))then
        print *,'ERROR: index kmass is out of range in limiter2d_minmax_lim3'
        stop '(kmass is out of range, lim3)'
      else
	do k=1,nlev
	  if(k.ne.kmass)then
	    Q(:,:,k)=Q(:,:,k)/Q(:,:,kmass)
	    call limiter2d_min_onelevel(Q(:,:,k),spheremv(:,:)*Q(:,:,kmass),qmin(k))
	    Q(:,:,k)=Q(:,:,k)*Q(:,:,kmass)
	  endif
	enddo
      endif
    else
      do k=1,nlev
	call limiter2d_min_onelevel(Q(:,:,k),spheremv(:,:),qmin(k))
      enddo
    endif


  end subroutine limiter2d_minmax_lim31

!-------------------------------------------------------------------------------
  subroutine limiter2d_min_onelevel(Q,spheremv,qmin)
    use kinds, only : real_kind
    use dimensions_mod, only : nv, np

    implicit none
    real (kind=real_kind), intent(inout)  :: Q(nv,nv)
    real (kind=real_kind), intent(in)  :: spheremv(nv,nv)
    real (kind=real_kind), intent(in)  :: qmin

    ! local
    integer i,j
    real (kind=real_kind) :: mass,mass_added,area,mass2

    if ( minval(Q(:,:)) < qmin ) then
      mass=sum( Q(:,:)*spheremv(:,:) )
      area=sum( spheremv(:,:) )
      mass2 = mass - area*qmin
      Q(:,:)=Q(:,:)-qmin

      ! negative mass.  so reduce all postive values to zero 
      ! then increase negative values as much as possible
      if (mass2 < 0) Q(:,:)=-Q(:,:) 
      mass_added=0
      do j=1,nv	
	  do i=1,nv
	    if (Q(i,j)<0) then
		Q(i,j)=0
	    else
		mass_added = mass_added + Q(i,j)*spheremv(i,j)
	    endif
	  enddo
      enddo
      ! now scale the all positive values to restore mass
      if (mass_added>0) Q(:,:) = Q(:,:)*abs(mass2)/mass_added
      if (mass2 < 0) Q(:,:)=-Q(:,:)         
      Q(:,:)=Q(:,:)+qmin
    endif

  end subroutine limiter2d_min_onelevel

!-------------------------------------------------------------------------------
  subroutine limiter2d_max_onelevel(Q,spheremv,qmax)
  
    use kinds, only : real_kind
    use dimensions_mod, only : nv, np

    implicit none
    real (kind=real_kind), intent(inout)  :: Q(nv,nv)
    real (kind=real_kind), intent(in)  :: spheremv(nv,nv)
    real (kind=real_kind), intent(in)  :: qmax

    ! local
    integer i,j
    real (kind=real_kind) :: mass,mass_added,area,mass2


    ! max limiter
    if ( maxval(Q(:,:)) > qmax ) then
       mass=sum( Q(:,:)*spheremv(:,:) )
       area=sum( spheremv(:,:) )
       mass2 = area*qmax - mass
       
      Q(:,:)=qmax-Q(:,:)

      if (mass2 < 0) Q(:,:)=-Q(:,:) 
      mass_added=0
      do j=1,nv	
	  do i=1,nv
	    if (Q(i,j)<0) then
		Q(i,j)=0
	    else
		mass_added = mass_added + Q(i,j)*spheremv(i,j)
	    endif
	  enddo
      enddo
      ! now scale the all positive values to restore mass
      if (mass_added>0) Q(:,:) = Q(:,:)*abs(mass2)/mass_added
      if (mass2 < 0) Q(:,:)=-Q(:,:) 
      Q(:,:)=qmax-Q(:,:)
    endif

  end subroutine limiter2d_max_onelevel

!---------------------------------------------------------------------------

  subroutine limiter2d_zero(Q,spheremv,kmass)
    !
    ! mass conserving sign-preserving limiter (2D only). 
    ! uses specified global minimum
    ! 
    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev
    use control_mod, only :  test_case

    implicit none
    real (kind=real_kind), intent(inout)  :: Q(nv,nv,nlev)
    real (kind=real_kind), intent(in)  :: spheremv(nv,nv)
    integer, intent(in) :: kmass

    ! local
    integer k
    real (kind=real_kind) :: qmin

    if(kmass.ne.-1)then
      do k=nlev,1,-1
	qmin=0
	if (test_case=='swirl') then
	    if (k.eq.1) qmin=0.1d0   ! lifted cosine bell
	    if (k.eq.3) qmin=0.1d0   ! lifted slotted cylinder
        endif
	if(k.ne.kmass)then
	  Q(:,:,k)=Q(:,:,k)/Q(:,:,kmass)
	  call limiter2d_min_onelevel(Q(:,:,k),spheremv(:,:)*Q(:,:,kmass),qmin)
	  Q(:,:,k)=Q(:,:,k)*Q(:,:,kmass)
	endif
      enddo
    else
      do k=nlev,1,-1
	qmin=0
	if (test_case=='swirl') then
	    if (k.eq.1) qmin=0.1d0   ! lifted cosine bell
	    if (k.eq.3) qmin=0.1d0   ! lifted slotted cylinder
	endif
	call limiter2d_min_onelevel(Q(:,:,k),spheremv(:,:),qmin)
      enddo
    endif
  end subroutine limiter2d_zero

!-------------------------------------------------------------------------------------


  subroutine advance_hypervis(edge3,elem,hybrid,deriv,vtens,ptens,nt,nets,nete,dt2)
    !
    !  take one timestep of:  
    !          u(:,:,:,np) = u(:,:,:,np) +  dt2*nu*laplacian**order ( u )
    !          h(:,:,:,np) = h(:,:,:,np) +  dt2*nu_s*laplacian**order ( h )
    !
    !   For height equation, we want to dissipate P.E. = gH^2, where H = surface height = h + h_surface
    !   since dH/dt = dh/dt, we can solve:
    !          h(:,:,:,np) = h(:,:,:,np) +  dt2*nu_s*laplacian**order ( H )
    !
    !   (to understand this, think of a flow at rest with topography.  H=constant,
    !    laplace(H)=0.  But h= -h_surface and laplacian(h) <> 0
    !
    !  For correct scaling, dt2 should be the same 'dt2' used in the leapfrog advace
    !
    !
    use kinds, only : real_kind
    use dimensions_mod, only : nv, np, nlev
    use control_mod, only : nu, nu_s, hypervis_order, hypervis_subcycle, limiter_option,&
	  test_case, kmass
    use hybrid_mod, only : hybrid_t
    use element_mod, only : element_t
    use derivative_mod, only : derivative_t, laplace_sphere_wk, vlaplace_sphere_wk
    use edge_mod, only : EdgeBuffer_t, edgevpack, edgevunpack
    use bndry_mod, only : bndry_exchangev
    use viscosity_mod, only : biharmonic_wk, neighbor_minmax
    ! ---------------------
    use reduction_mod, only : ParallelSum
    implicit none

    type (hybrid_t)      , intent(in) :: hybrid
    type (element_t)     , intent(inout), target :: elem(:)
    real (kind=real_kind), dimension(nv,nv,2,nlev,nets:nete)  :: vtens
    real (kind=real_kind), dimension(np,np,nlev,nets:nete) :: ptens
    type (EdgeBuffer_t)  , intent(inout) :: edge3
    type (derivative_t)  , intent(in) :: deriv
    real (kind=real_kind) :: dt2
    integer :: nt,nets,nete


    ! local
    integer :: k,kptr,i,j,ie,ic
    real (kind=real_kind), dimension(:,:), pointer :: spheremv,rspheremv
    real (kind=real_kind), dimension(nv,nv) :: ptot
    real (kind=real_kind), dimension(nv,nv) :: lap_p
    real (kind=real_kind), dimension(nv,nv,2) :: lap_v
    real (kind=real_kind) :: v1,v2,dt
    real (kind=real_kind) :: pmin(nlev,nets:nete),pmax(nlev,nets:nete)
    real (kind=real_kind) :: notreliable(nets:nete), notreliable_sum


    if (hypervis_order == 0 ) return;
    if (nu_s == 0 .and. nu == 0 ) return;



!should be no limiter -- no division, but not today
       if(kmass.ne.-1)then
	  do ie=nets,nete
	      do k=1,nlev
		if(k.ne.kmass)then
		  elem(ie)%state%p(:,:,k,nt)=elem(ie)%state%p(:,:,k,nt)/&
                                             elem(ie)%state%p(:,:,kmass,nt)
                endif
	      enddo
	  enddo
       endif

!group of lim3 limiters, redistribution
       if ( (limiter_option == 3 ).or.( limiter_option == 31 )) then
          call neighbor_minmax(elem,hybrid,edge3,nets,nete,nt,pmin,pmax)
       endif


!go back to old (\rho q) fields
       if(kmass.ne.-1)then
	  do ie=nets,nete
	      do k=1,nlev
		if(k.ne.kmass)then
		  elem(ie)%state%p(:,:,k,nt)=elem(ie)%state%p(:,:,k,nt)*&
                                             elem(ie)%state%p(:,:,kmass,nt)
                endif
	      enddo
	  enddo
       endif



    do ie=nets,nete
       do k=1,nlev

          ! contra -> latlon
          do j=1,nv
             do i=1,nv
                v1     = elem(ie)%state%v(i,j,1,k,nt)   ! contra
                v2     = elem(ie)%state%v(i,j,2,k,nt)   ! contra 
                elem(ie)%state%v(i,j,1,k,nt)=elem(ie)%D(1,1,i,j)*v1 + elem(ie)%D(1,2,i,j)*v2   ! contra->latlon
                elem(ie)%state%v(i,j,2,k,nt)=elem(ie)%D(2,1,i,j)*v1 + elem(ie)%D(2,2,i,j)*v2   ! contra->latlon
             enddo
          enddo
       enddo
    enddo


    dt=dt2/hypervis_subcycle

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !  regular viscosity  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (hypervis_order == 1) then

       do ic=1,hypervis_subcycle
          do ie=nets,nete

             spheremv     => elem(ie)%spheremv

             do k=1,nlev
                ! filter surface height, not thickness
                do j=1,nv
                   do i=1,nv             
                      ptot(i,j)=elem(ie)%state%p(i,j,k,nt) + elem(ie)%state%ps(i,j)
                   enddo
                enddo

                lap_p=laplace_sphere_wk(ptot,deriv,elem(ie))
                lap_v=vlaplace_sphere_wk(elem(ie)%state%v(:,:,:,k,nt),deriv,elem(ie))
                ! advace in time.  (note: DSS commutes with time stepping, so we
                ! can time advance and then DSS.  this has the advantage of
                ! not letting any discontinuties accumulate in p,v via tol
                do j=1,nv
                   do i=1,nv             
                      elem(ie)%state%p(i,j,k,nt)=elem(ie)%state%p(i,j,k,nt)*spheremv(i,j)  +  dt*nu_s*lap_p(i,j) 
                      elem(ie)%state%v(i,j,1,k,nt)=elem(ie)%state%v(i,j,1,k,nt)*spheremv(i,j) + dt*nu*lap_v(i,j,1)
                      elem(ie)%state%v(i,j,2,k,nt)=elem(ie)%state%v(i,j,2,k,nt)*spheremv(i,j) + dt*nu*lap_v(i,j,2)
                   enddo
                enddo
             enddo

             kptr=0
             call edgeVpack(edge3, elem(ie)%state%p(:,:,:,nt),nlev,kptr,elem(ie)%desc)
             kptr=nlev
             call edgeVpack(edge3,elem(ie)%state%v(:,:,:,:,nt),2*nlev,kptr,elem(ie)%desc)
          enddo

          call bndry_exchangeV(hybrid,edge3)

          do ie=nets,nete
             rspheremv     => elem(ie)%rspheremv

             kptr=0
             call edgeVunpack(edge3, elem(ie)%state%p(:,:,:,nt), nlev, kptr, elem(ie)%desc)
             kptr=nlev
             call edgeVunpack(edge3, elem(ie)%state%v(:,:,:,:,nt), 2*nlev, kptr, elem(ie)%desc)

             ! apply inverse mass matrix
             do k=1,nlev
                do j=1,nv
                   do i=1,nv             
                      elem(ie)%state%p(i,j,k,nt)=rspheremv(i,j)*elem(ie)%state%p(i,j,k,nt)
                      elem(ie)%state%v(i,j,1,k,nt)=rspheremv(i,j)*elem(ie)%state%v(i,j,1,k,nt)
                      elem(ie)%state%v(i,j,2,k,nt)=rspheremv(i,j)*elem(ie)%state%v(i,j,2,k,nt)
                   enddo
                enddo
             enddo
          enddo
       enddo  ! subcycle
    endif


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !  hyper viscosity  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (hypervis_order == 2) then
       do ic=1,hypervis_subcycle

          call biharmonic_wk(elem,ptens,vtens,deriv,edge3,hybrid,nt,nets,nete)

          do ie=nets,nete

             spheremv     => elem(ie)%spheremv
             do k=1,nlev
                ! advace in time.  
                ! note: DSS commutes with time stepping, so we can time advance and then DSS.
                ! note: weak operators alreayd have mass matrix "included"

                do j=1,nv
                   do i=1,nv
                      elem(ie)%state%p(i,j,k,nt)  =  elem(ie)%state%p(i,j,k,nt)*spheremv(i,j)  -dt*nu_s*ptens(i,j,k,ie)
                      elem(ie)%state%v(i,j,1,k,nt)=elem(ie)%state%v(i,j,1,k,nt)*spheremv(i,j) - dt*nu*vtens(i,j,1,k,ie)
                      elem(ie)%state%v(i,j,2,k,nt)=elem(ie)%state%v(i,j,2,k,nt)*spheremv(i,j) - dt*nu*vtens(i,j,2,k,ie)
                   enddo
                enddo
             enddo

             ! smooth some of the negativities introduced by diffusion:
             if (test_case=="swtc1" .or. test_case=="vortex" .or. test_case=="swirl") then

                   ! this routine takes p  (not p*spheremv)
                   do k=1,nlev
                      elem(ie)%state%p(:,:,k,nt)  =  elem(ie)%state%p(:,:,k,nt)/spheremv(:,:)
                   enddo

                   notreliable(ie)=0.0
		   if (limiter_option == 3) then
		      call limiter2d_minmax_lim3(elem(ie)%state%p(:,:,:,nt),elem(ie)%spheremv,&
                        pmin(:,ie),pmax(:,ie),kmass)
		   elseif(limiter_option == 31) then
		      call limiter2d_minmax_lim31(elem(ie)%state%p(:,:,:,nt),elem(ie)%spheremv,&
                        pmin(:,ie),kmass)
		   elseif ((limiter_option == 8))then
		      call limiter_optim_iter_full(elem(ie)%state%p(:,:,:,nt),elem(ie)%spheremv(:,:),&
		      pmin(:,ie),pmax(:,ie), kmass,.true.,.true.,notreliable(ie))
		   elseif ((limiter_option == 81))then
		      call limiter_optim_iter_full(elem(ie)%state%p(:,:,:,nt),elem(ie)%spheremv(:,:),&
		      pmin(:,ie),pmax(:,ie), kmass,.true.,.false.,notreliable(ie))
          	   else
		      call limiter2d_zero(elem(ie)%state%p(:,:,:,nt),elem(ie)%spheremv,kmass)
		   endif

                   do k=1,nlev
                      elem(ie)%state%p(:,:,k,nt)  =  elem(ie)%state%p(:,:,k,nt)*spheremv(:,:)
                   enddo

             endif


             kptr=0
             call edgeVpack(edge3, elem(ie)%state%p(:,:,:,nt),nlev,kptr,elem(ie)%desc)
             kptr=nlev
             call edgeVpack(edge3,elem(ie)%state%v(:,:,:,:,nt),2*nlev,kptr,elem(ie)%desc)
          enddo


	  if(( limiter_option == 8).or.( limiter_option == 81))then
	    notreliable_sum=ParallelSum(notreliable,hybrid)
	  endif

	  if((hybrid%par%masterproc .and. hybrid%ithr==0).and.(notreliable_sum>0)) then 
	    write (*,*) 'WARNING: optimal limiter might have failed,'
	    write (*,*) 'either we are bouncing around tol, &
	    or do not use lim8(or 81), \n or reduce timestep'
	  endif

          call bndry_exchangeV(hybrid,edge3)

          do ie=nets,nete
             rspheremv     => elem(ie)%rspheremv

             kptr=0
             call edgeVunpack(edge3, elem(ie)%state%p(:,:,:,nt), nlev, kptr, elem(ie)%desc)
             kptr=nlev
             call edgeVunpack(edge3, elem(ie)%state%v(:,:,:,:,nt), 2*nlev, kptr, elem(ie)%desc)

             ! apply inverse mass matrix
             do k=1,nlev
                do j=1,nv
                   do i=1,nv
                      elem(ie)%state%p(i,j,k,nt)=rspheremv(i,j)*elem(ie)%state%p(i,j,k,nt)
                      elem(ie)%state%v(i,j,1,k,nt)=rspheremv(i,j)*elem(ie)%state%v(i,j,1,k,nt)
                      elem(ie)%state%v(i,j,2,k,nt)=rspheremv(i,j)*elem(ie)%state%v(i,j,2,k,nt)
                   enddo
                enddo
             enddo
          enddo
       enddo
    endif


    ! convert lat-lon -> contra variant
    do ie=nets,nete
       do k=1,nlev
          do j=1,nv
             do i=1,nv
                v1=elem(ie)%state%v(i,j,1,k,nt)
                v2=elem(ie)%state%v(i,j,2,k,nt)
                elem(ie)%state%v(i,j,1,k,nt) = elem(ie)%Dinv(1,1,i,j)*v1 + elem(ie)%Dinv(1,2,i,j)*v2
                elem(ie)%state%v(i,j,2,k,nt) = elem(ie)%Dinv(2,1,i,j)*v1 + elem(ie)%Dinv(2,2,i,j)*v2
             enddo
          enddo
       enddo
    enddo


    ! lat-lon conversion 1740  20%
    ! opss+pack+mass     5937  68% 
    ! unpack+mass_inv    1015  12%     
    ! total 8692
  end subroutine advance_hypervis
#endif

!-----------------------------------------------------------------------------------

  subroutine advance_si_nonstag(elem, edge1,edge2,   edge3 ,  red     ,            &
       deriv,                    &
       flt  ,                   &
       cg   ,   blkjac    ,  lambdasq, &
       dt   ,   pmean ,  tl      ,            &
       nets ,    nete)

    ! ---------------------
    use kinds, only : real_kind
    ! ---------------------
    use physical_constants, only : rearth 
    ! ---------------------
    use dimensions_mod, only : nv, np, nlev
    ! ---------------------
    use element_mod, only : element_t
    ! ---------------------
    use edge_mod, only : EdgeBuffer_t, edgevpack, edgerotate, edgevunpack
    ! ---------------------
    use filter_mod, only : filter_t, filter_P, filter_V
    ! ---------------------
    use hybrid_mod, only : hybrid_t
    ! ---------------------
    use reduction_mod, only : reductionbuffer_ordered_1d_t
    ! ---------------------
    !    use parallel_mod
    ! ---------------------
    use derivative_mod, only : derivative_t,  gradient_wk, divergence, &
         vorticity, gradient, interpolate_v2p
    ! ---------------------
    use time_mod, only : timelevel_t, smooth
    ! ---------------------
    use control_mod, only : filter_freq, filter_counter, topology, test_case, precon_method
    ! ---------------------
    use shallow_water_mod, only : tc1_velocity
    ! ---------------------
    use cg_mod, only : cg_t
    ! ---------------------
    use solver_mod, only : pcg_solver, blkjac_t, blkjac_init
    ! ---------------------
    use bndry_mod, only : bndry_exchangev
    ! ---------------------
    use perf_mod, only : t_startf, t_stopf ! _EXTERNAL
    ! ---------------------
    !    use schedule_mod
    ! ---------------------
    implicit none
    type (element_t), intent(inout), target :: elem(:)
    type (EdgeBuffer_t)               :: edge1
    type (EdgeBuffer_t)               :: edge2
    type (EdgeBuffer_t)               :: edge3
    type (ReductionBuffer_ordered_1d_t)     :: red
    type (derivative_t)               :: deriv
    type (filter_t)                   :: flt
    type (cg_t)                       :: cg

    integer              , intent(in) :: nets
    integer              , intent(in) :: nete
    type (blkjac_t)                   :: blkjac(nets:nete)

    real (kind=real_kind), intent(in) :: dt
    real (kind=real_kind), intent(in) :: pmean
    real (kind=real_kind), intent(inout) :: lambdasq(nlev)
    type (TimeLevel_t)   , intent(in) :: tl
    ! =================
    ! Local Variables
    ! =================

    ! pointers ...

    real (kind=real_kind), dimension(:,:), pointer     :: mp
    real (kind=real_kind), dimension(:,:), pointer     :: metdetp

    real (kind=real_kind), dimension(:,:), pointer     :: fcor
    real (kind=real_kind), dimension(:,:), pointer     :: rmv
    real (kind=real_kind), dimension(:,:), pointer     :: mv
    real (kind=real_kind), dimension(:,:), pointer     :: metdet
    real (kind=real_kind), dimension(:,:), pointer     :: rmetdetp
    real (kind=real_kind), dimension(:,:,:,:), pointer :: met
    real (kind=real_kind), dimension(:,:,:,:), pointer :: metinv

    ! Thread private working set ...

    real (kind=real_kind), dimension(nv,nv,2,nlev,nets:nete)  :: Ru
    real (kind=real_kind), dimension(nv,nv,2,nlev,nets:nete)  :: grad_dp
    real (kind=real_kind), dimension(nv,nv,nlev,nets:nete)    :: vgradp     ! v.grad(p) on velocity grid
    real (kind=real_kind), dimension(np,np,nlev,nets:nete)    :: Rs   
    real (kind=real_kind), dimension(np,np,nlev,nets:nete)    :: dp ! solution to Helmholtz equation

    real (kind=real_kind), dimension(nv,nv,2)    :: gradp      ! weak pressure gradient, time level (n  )
    real (kind=real_kind), dimension(nv,nv,2)    :: gradpm1    ! weak pressure gradient, time level (n-1)
    real (kind=real_kind), dimension(nv,nv,2)    :: grade      ! strong kinetic energy gradient
    real (kind=real_kind), dimension(nv,nv,2)    :: gvm1       ! metdet*v(n-1), v contravariant
    real (kind=real_kind), dimension(nv,nv,2)    :: gv         ! metdet*v(n-1), v contravariant
    real (kind=real_kind), dimension(nv,nv,2)    :: vco        ! covariant velocity

    real (kind=real_kind), dimension(nv,nv)      :: E          ! kinetic energy term
    real (kind=real_kind), dimension(nv,nv)      :: zeta       ! relative vorticity

    real (kind=real_kind), dimension(np,np)      :: div        ! timestep n   velocity divergence (p-grid)
    real (kind=real_kind), dimension(np,np)      :: divm1      ! timestep n-1 velocity divergence (p-grid)

    real (kind=real_kind) ::  v1,v2
    real (kind=real_kind) ::  gradp1,gradp2
    real (kind=real_kind) ::  grad_dp1,grad_dp2
    real (kind=real_kind) ::  Ru1,Ru2,Rp

    real (kind=real_kind) ::  dx,dy,rdx,rdy
    real (kind=real_kind) ::  lenscale
    real (kind=real_kind) ::  dt2
    real (kind=real_kind) ::  time_adv

    real*8  :: et,st
    integer i,j,k,ie
    integer kptr
    integer point
    integer iptr
    integer nm1,n0,np1
    integer nstep

    real (kind=real_kind) :: tmp1
    real (kind=real_kind) :: p0sum,v0sum

    call t_startf('advance_si_nonstag')

    if ( dt /= initialized_for_dt ) then
       if(cg%hybrid%par%masterproc) print *,'Initializing semi-implicit matricies for dt=',dt

       lambdasq(:) = pmean*dt*dt
       if (precon_method == "block_jacobi") then
          call blkjac_init(elem, deriv,lambdasq,nets,nete,blkjac)
       end if
       initialized_for_dt = dt
    endif



    nm1 = tl%nm1
    n0  = tl%n0
    np1 = tl%np1
    nstep = tl%nstep

    dt2 = 2*dt

    !DBG print *,'advance_si: point #1'
    lenscale=rearth
    !DBG print *,'advance_si: point #2'

    !$OMP BARRIER

#if 0
    v0sum=0.0D0
    p0sum=0.0D0
    do ie=nets,nete
       v0sum=v0sum + SUM(elem(ie)%state%v(:,:,:,:,n0))
       p0sum=p0sum + SUM(elem(ie)%state%p(:,:,:,n0))
       print *,ie,"SUMv,SUMp=",SUM(elem(ie)%state%v(:,:,:,:,n0)),SUM(elem(ie)%state%p(:,:,:,n0))
    end do
    print *,cg%hybrid%ithr,"afilt: sum v(n0),p(n0)=",v0sum,p0sum
#endif

    ! ====================
    ! Call Filter...
    ! ====================
    !DBG print *,'advance_si: point #3'

    if (nstep > 0 .and. filter_freq > 0 .and. MODULO(nstep,filter_freq) == 0 ) then

       !DBG print *,'advance_si: point #4'
       do ie=nets,nete
          do k=1,nlev
             call filter_P(elem(ie)%state%p(:,:,k,n0),flt)
             call filter_V(elem(ie)%state%v(:,:,1,k,n0),flt)
             call filter_V(elem(ie)%state%v(:,:,2,k,n0),flt)

             do j=1,nv
                do i=1,nv
                   elem(ie)%state%v(i,j,1,k,n0) = elem(ie)%mv(i,j)*elem(ie)%state%v(i,j,1,k,n0)
                   elem(ie)%state%v(i,j,2,k,n0) = elem(ie)%mv(i,j)*elem(ie)%state%v(i,j,2,k,n0)
                   elem(ie)%state%p(i,j,k,n0)   = elem(ie)%mv(i,j)*elem(ie)%state%p(i,j,k,n0)
                end do
             end do

          end do
          kptr=0
          call edgeVpack(edge3, elem(ie)%state%v(:,:,:,:,n0),2*nlev,kptr,elem(ie)%desc)
          kptr=2*nlev
          call edgeVpack(edge3, elem(ie)%state%p(:,:,:,n0),nlev,kptr,elem(ie)%desc)
          kptr=0
          !DBG print *,'advance_si: point #6'
          call edgerotate(edge3,2*nlev,kptr,elem(ie)%desc)
          !DBG print *,'advance_si: point #7'
       end do

       !DBG print *,'advance_si: point #8'
       !$OMP BARRIER

       call bndry_exchangeV(cg%hybrid,edge3)
       !$OMP BARRIER

       do ie=nets,nete

          kptr=0
          call edgeVunpack(edge3, elem(ie)%state%v(:,:,:,:,n0), 2*nlev, kptr, elem(ie)%desc)
          kptr=2*nlev
          call edgeVunpack(edge3, elem(ie)%state%p(:,:,:,n0), nlev, kptr, elem(ie)%desc)

          do k=1,nlev
             do j=1,nv
                do i=1,nv
                   elem(ie)%state%v(i,j,1,k,n0) = elem(ie)%rmv(i,j)*elem(ie)%state%v(i,j,1,k,n0)
                   elem(ie)%state%v(i,j,2,k,n0) = elem(ie)%rmv(i,j)*elem(ie)%state%v(i,j,2,k,n0)
                   elem(ie)%state%p(i,j,k,n0)   = elem(ie)%rmv(i,j)*elem(ie)%state%p(i,j,k,n0)
                end do
             end do
          end do

       end do

       !$OMP BARRIER

    end if
    !DBG print *,'advance_si: point #10'

    do ie=nets,nete

       ! scale  by rearth to get scaling right between phi and v.
       ! assumes dx,dy are used only by the weak gradient routine (sgradient)

       dx=0.5D0*elem(ie)%dx/lenscale ! weak derivative element x dimension
       dy=0.5D0*elem(ie)%dy/lenscale    ! weak derivative element y dimension
       rdx=2.0D0/(elem(ie)%dx*lenscale) ! strong derivative inverse x length
       rdy=2.0D0/(elem(ie)%dy*lenscale) ! strong derivative inverse y length

       mv => elem(ie)%mv
       fcor => elem(ie)%fcor
       metdet => elem(ie)%metdet
       metinv => elem(ie)%metinv

       !JMD       TIMER_DETAIL_START(timer,2,st)
       !JMD metdet => elem(ie)%metdet
       !JMD if(TIMER_DETAIL(2,timer)) then
       !JMD	 TIMER_START(et)
       !JMD	 timer%pointers = timer%pointers + (et - st)
       !JMD       endif

       !DBG print *,'advance_si: point #11'
       do k=1,nlev

          ! ==============================================
          !
          ! Compute gradient of pressure field at time 
          ! level n-1 and n
          ! 
          !   2 x {2.0*(nv+np)*nv*(2.0*np-1.0) + 2*nv*nv} Flops
          !
          ! ==============================================
! this would become gradient_sphere

#ifdef _WK_GRAD
          gradpm1(:,:,:)=gradient_wk(elem(ie)%state%p(:,:,k,nm1),deriv,dx,dy)
          gradp(:,:,:)  =gradient_wk(elem(ie)%state%p(:,:,k,n0), deriv,dx,dy)
#else
          gradpm1(:,:,:)=gradient(elem(ie)%state%p(:,:,k,nm1),deriv,dx,dy)
          gradp(:,:,:)  =gradient(elem(ie)%state%p(:,:,k,n0), deriv,dx,dy)
#endif

          ! ==============================================
          !
          ! Compute kinetic energy term: 10*nv*nv Flops
          !
          ! ==============================================
          do j=1,nv
             do i=1,nv
                v1     = elem(ie)%state%v(i,j,1,k,n0)
                v2     = elem(ie)%state%v(i,j,2,k,n0)

                vco(i,j,1) = elem(ie)%met(1,1,i,j)*v1 + elem(ie)%met(1,2,i,j)*v2
                vco(i,j,2) = elem(ie)%met(2,1,i,j)*v1 + elem(ie)%met(2,2,i,j)*v2

                E(i,j) = 0.5D0*( vco(i,j,1)*v1 + vco(i,j,2)*v2 )

             end do
          end do

          ! =========================================
          !
          ! Compute metdet * relative vorticity (zeta)
          !
          !   2.0*nv*nv*(2.0*nv-1.0) + 3 nv*nv Flops
          !
          ! =========================================

          !DBG print *,'advance_si: point #12'
          zeta(:,:)  = vorticity(vco,deriv,rdx,rdy)

          ! ==============================================
          !
          ! Compute vgradient of kinetic energy field
          !
          !   2.0*nv*nv*(2.0*np-1.0) + 2*nv*nv Flops
          !
          ! ==============================================
          grade(:,:,:)=gradient(E,deriv,rdx,rdy)


          ! ==============================================
          !
          ! Compute Ru^i and v.grad(p) term
          !
          !    23*nv*nv Flops
          !
          ! ==============================================
          !DBG print *,'advance_si: point #13 ie:=',ie
          do j=1,nv
             do i=1,nv

!make sure its consistent lat lon NOT not contra or co-variant
                Ru1 =  mv(i,j)*(   elem(ie)%state%v(i,j,2,k,n0)*(metdet(i,j)*fcor(i,j) + zeta(i,j)) &
                     - grade(i,j,1))                                              &
                     + gradpm1(i,j,1) + elem(ie)%state%gradps(i,j,1)

                Ru2 =  mv(i,j)*( - elem(ie)%state%v(i,j,1,k,n0)*(metdet(i,j)*fcor(i,j) + zeta(i,j)) &
                     - grade(i,j,2))                                               &
                     + gradpm1(i,j,2) + elem(ie)%state%gradps(i,j,2)
                Ru(i,j,1,k,ie)   = dt2*(metinv(1,1,i,j)*Ru1 + metinv(1,2,i,j)*Ru2)
                Ru(i,j,2,k,ie)   = dt2*(metinv(2,1,i,j)*Ru1 + metinv(2,2,i,j)*Ru2)

                vgradp(i,j,k,ie)  =  elem(ie)%state%v(i,j,1,k,n0)*gradp(i,j,1) + &
                     elem(ie)%state%v(i,j,2,k,n0)*gradp(i,j,2)

             end do
          end do
       end do


       ! ===================================================
       !
       ! Pack cube edges of grad(p) and V.grad(V) 
       ! into edge buffer
       !
       ! ===================================================

       !DBG print *,'advance_si: point #14'
       kptr=0
       call edgeVpack(edge3, vgradp(1,1,1,ie),nlev,kptr,elem(ie)%desc)

       kptr=nlev
       call edgeVpack(edge3,Ru(1,1,1,1,ie),2*nlev,kptr,elem(ie)%desc)
       !DBG print *,'advance_si: point #15'

       ! =============================================================
       !
       ! Rotate edges (if necessary, e.g. if we're on the cube)
       !
       ! ============================================================= 

       !DBG print *,'advance_si: point #15.1'
       kptr=nlev
       call edgerotate(edge3,2*nlev,kptr,elem(ie)%desc)
       !DBG print *,'advance_si: point #15.2'
    end do

    ! =============================================================
    ! Insert communications here: for shared memory, just a single
    ! thread barrier is required
    ! =============================================================

    call bndry_exchangeV(cg%hybrid,edge3)
    !$OMP BARRIER

    do ie=nets,nete

       rdx=2.0D0/(elem(ie)%dx*lenscale)
       rdy=2.0D0/(elem(ie)%dy*lenscale)

       rmv     => elem(ie)%rmv
       mp      => elem(ie)%mp
       mv      => elem(ie)%mv
       metdet  => elem(ie)%metdet
       metdetp => elem(ie)%metdetp
       rmetdetp=> elem(ie)%rmetdetp

       ! ===========================================================
       ! Unpack the edges for vgradp and vtens
       !   3*4*(nv+1)
       ! ===========================================================

       kptr=0
       call edgeVunpack(edge3, vgradp(1,1,1,ie), nlev, kptr, elem(ie)%desc)

       kptr=nlev
       call edgeVunpack(edge3, Ru(1,1,1,1,ie), 2*nlev, kptr, elem(ie)%desc)

       ! ===========================================================
       ! Compute velocity and pressure tendencies for all levels
       ! ===========================================================

       do k=1,nlev

          ! =========================================================
          !
          ! Scale velocity tendency and v.grad(p) term by inverse mass
          ! matrix, scale velocity by metric g factor.
          !
          !     11 nv*nv Flops
          !
          ! =========================================================

          do j=1,nv
             do i=1,nv
                vgradp(i,j,k,ie) = rmv(i,j)*vgradp(i,j,k,ie)

                Ru(i,j,1,k,ie) = rmv(i,j)*Ru(i,j,1,k,ie)
                Ru(i,j,2,k,ie) = rmv(i,j)*Ru(i,j,2,k,ie)

                gv(i,j,1)   = metdet(i,j)*elem(ie)%state%v(i,j,1,k,n0)
                gv(i,j,2)   = metdet(i,j)*elem(ie)%state%v(i,j,2,k,n0)

                gvm1(i,j,1) = metdet(i,j)*(elem(ie)%state%v(i,j,1,k,nm1) + 0.5D0*Ru(i,j,1,k,ie))
                gvm1(i,j,2) = metdet(i,j)*(elem(ie)%state%v(i,j,2,k,nm1) + 0.5D0*Ru(i,j,2,k,ie))

             end do
          end do
          ! ==========================================================
          !
          ! Compute divergence of metdet*v(n  ), v(n  ) contravariant
          ! Compute divergence of metdet*v(n-1), v(n-1) contravariant
          !
          !  2 x [ 2*(np+nv)*np*(2*nv-1) + 3*np*np ] Flops
          ! ==========================================================

          div    = divergence(gv  ,deriv,rdx,rdy)
          divm1  = divergence(gvm1,deriv,rdx,rdy)

          ! ====================================================
          ! Compute the Right Hand Side of the Helmholtz eq
          !
          !    7*np*np Flops
          !
          ! ====================================================

          iptr=1
          do j=1,np
             do i=1,np
                Rs(i,j,k,ie) = dt2*mv(i,j)*(vgradp(i,j,k,ie)*metdetp(i,j)   &
                     - elem(ie)%state%p(i,j,k,n0)*div(i,j)       &
                     -                 pmean*divm1(i,j))
             end do
          end do

       end do
       !DBG print *,'advance_si: point #14'
       kptr=0
       call edgeVpack(edge1, Rs(1,1,1,ie),nlev,kptr,elem(ie)%desc)

    end do
#if 0
    print *,cg%hybrid%ithr,"advance_si Rs=",SUM(Rs(:,:,1,nets:nete)**2)
    call haltmp("__FILE__"//":__LINE__")
#endif


    call bndry_exchangeV(cg%hybrid,edge1)
    !$OMP BARRIER

    do ie=nets,nete

       rmv     => elem(ie)%rmv
       kptr=0
       call edgeVunpack(edge1, Rs(1,1,1,ie), nlev, kptr, elem(ie)%desc)
       do k=1,nlev
          do j=1,nv
             do i=1,nv
                Rs(i,j,k,ie) = rmv(i,j)*Rs(i,j,k,ie)
             enddo
          enddo
       enddo
    enddo

    ! ======================================================
    ! Invoke the solver!
    ! ======================================================

    !DBG print *,'advance_si: before call to pcg_solver'
    point = 3
#ifdef _HTRACE
    !JMD    call EVENT_POINT(point)
#endif
    !$OMP BARRIER


    dp(:,:,:,nets:nete) = pcg_solver(elem, &
	 Rs(:,:,:,nets:nete),  &     ! rhs of Helmholtz problem
         cg,              &     ! cg struct
         red,             &     ! reduction buffer
         edge1 ,          &     ! single vector edge exchange buffer
         edge2 ,          &     ! single vector edge exchange buffer
         lambdasq,        &     ! Helmholtz length scale squared
         deriv,      &     ! staggered derivative struct
         nets,            &     ! starting element number
         nete,            &     ! ending   element number
         blkjac)
    point = 4 


#ifdef _HTRACE
    !JMD   call EVENT_POINT(point)
#endif

    do ie=nets,nete

       dx=0.5D0*elem(ie)%dx/lenscale    ! weak derivative element x dimension
       dy=0.5D0*elem(ie)%dy/lenscale    ! weak derivative element y dimension

       metinv => elem(ie)%metinv

       do k=1,nlev

          ! compute grad dp needed to back substitute for du

#ifdef _WK_GRAD
          grad_dp(:,:,:,k,ie)=gradient_wk(dp(:,:,k,ie),deriv,dx,dy)
#else
          grad_dp(:,:,:,k,ie)=gradient(dp(:,:,k,ie),deriv,dx,dy)
#endif


          ! ==================================================
          ! Rotate grad_dp to form contravariant object:
          !        6 nv*nv Flops
          ! ==================================================

          do j=1,nv
             do i=1,nv
                grad_dp1 = grad_dp(i,j,1,k,ie)
                grad_dp2 = grad_dp(i,j,2,k,ie)
                grad_dp(i,j,1,k,ie) = elem(ie)%metinv(1,1,i,j)*grad_dp1 + elem(ie)%metinv(1,2,i,j)*grad_dp2
                grad_dp(i,j,2,k,ie) = elem(ie)%metinv(2,1,i,j)*grad_dp1 + elem(ie)%metinv(2,2,i,j)*grad_dp2

             end do
          end do

       enddo

       kptr=0
       call edgeVpack(edge2, grad_dp(1,1,1,1,ie),2*nlev,kptr,elem(ie)%desc)
       kptr=0
       call edgerotate(edge2,2*nlev,kptr,elem(ie)%desc)
    end do

    !$OMP BARRIER
    call bndry_exchangeV(cg%hybrid,edge2)
    !$OMP BARRIER
    do ie=nets,nete
       rmv => elem(ie)%rmv


       kptr=0      

       call edgeVunpack(edge2, grad_dp(1,1,1,1,ie), 2*nlev, kptr, elem(ie)%desc)

       do k=1,nlev

          ! ==============================
          ! Update geopotential
          !    6 np*np Flops
          ! ==============================


          iptr=1
          do j=1,np
             do i=1,np
                elem(ie)%state%p(i,j,k,np1) = elem(ie)%state%p(i,j,k,nm1) + dp(i,j,k,ie)
                elem(ie)%state%p(i,j,k,n0)  = elem(ie)%state%p(i,j,k,n0) + smooth*(elem(ie)%state%p(i,j,k,nm1) &
                     - 2.0D0*elem(ie)%state%p(i,j,k,n0) + elem(ie)%state%p(i,j,k,np1))
                iptr=iptr+1
             end do
          end do

          ! ==============================
          ! Update velocity
          !    16 nv*nv Flops
          ! ==============================

          do j=1,nv
             do i=1,nv
                grad_dp1 = rmv(i,j)*grad_dp(i,j,1,k,ie)
                grad_dp2 = rmv(i,j)*grad_dp(i,j,2,k,ie)

                elem(ie)%state%v(i,j,1,k,np1) = elem(ie)%state%v(i,j,1,k,nm1) + Ru(i,j,1,k,ie) + dt*grad_dp1
                elem(ie)%state%v(i,j,2,k,np1) = elem(ie)%state%v(i,j,2,k,nm1) + Ru(i,j,2,k,ie) + dt*grad_dp2
                elem(ie)%state%v(i,j,1,k,n0)  = elem(ie)%state%v(i,j,1,k,n0) + smooth*(elem(ie)%state%v(i,j,1,k,nm1) &
                     - 2.0D0*elem(ie)%state%v(i,j,1,k,n0) + elem(ie)%state%v(i,j,1,k,np1))
                elem(ie)%state%v(i,j,2,k,n0)  = elem(ie)%state%v(i,j,2,k,n0) + smooth*(elem(ie)%state%v(i,j,2,k,nm1) &
                     - 2.0D0*elem(ie)%state%v(i,j,2,k,n0) + elem(ie)%state%v(i,j,2,k,np1))

             end do
          end do
       end do
    end do

    call t_stopf('advance_si_nonstag')

    !$OMP BARRIER

  end subroutine advance_si_nonstag


!----------------------------------------------------------------------------------------


  subroutine set_prescribed_velocity(elem,n0,time)
  use control_mod, only :  topology, test_case
  use element_mod, only : element_t
  use dimensions_mod, only : nv, np, nlev
  use shallow_water_mod, only : tc1_velocity, vortex_velocity, swirl_velocity
  implicit none

  type (element_t)     , intent(inout) :: elem

  ! local
  integer :: n0,k
  real (kind=real_kind) :: time

  if (topology == "cube" .and. test_case=="swtc1") then
     do k=1,nlev
        elem%state%v(:,:,:,k,n0)=tc1_velocity(elem%spherev,elem%Dinv)
     end do
  else if (topology == "cube" .and. test_case=="vortex") then                
     do k=1,nlev
        elem%state%v(:,:,:,k,n0)=vortex_velocity(time,elem%spherev,elem%Dinv)
     end do
  else if (topology == "cube" .and. test_case=="swirl") then                
     do k=1,nlev
        elem%state%v(:,:,:,k,n0)=swirl_velocity(time,elem%spherev,elem%Dinv)
     end do

  end if
  end subroutine set_prescribed_velocity

!----------------------------------------------------------------------------------------


  subroutine compute_and_apply_rhs(np1,nm1,n0,dt2,real_time,edge3,elem,pmean,hybrid,deriv,vtens,ptens,nets,nete)
  ! ===================================
  ! compute the RHS, accumulate into u(np1) and apply DSS
  !
  !           u(np1) = u(nm1) + dt2*DSS[ RHS(u(n0)) ]
  !
  ! This subroutine is normally called to compute a leapfrog timestep
  ! but by adjusting np1,nm1,n0 and dt2, many other timesteps can be
  ! accomodated.  For exaple, setting nm1=np1=n0 this routine will
  ! take a forward euler step, overwriting the input with the output.
  !
  ! if  dt2=0, then the DSS'd RHS is returned in vtens,ptens
  ! and u(np1) is not changed.  
  !
  ! Combining the RHS and DSS pack operation in one routine 
  ! allows us to fuse these two loops for more cache reuse
  !
  ! Combining the dt advance and DSS unpack operation in one routine 
  ! allows us to fuse these two loops for more cache reuse
  !
  ! note: for prescribed velocity case, velocity will be computed at
  ! "real_time", which should be the time of timelevel n0.  
  ! ===================================
  use kinds, only : real_kind
  use dimensions_mod, only : nv, np, nlev
  use hybrid_mod, only : hybrid_t
  use element_mod, only : element_t
  use derivative_mod, only : derivative_t, divergence_sphere, gradient_sphere, vorticity_sphere
  use edge_mod, only : EdgeBuffer_t, edgevpack, edgevunpack
  use bndry_mod, only : bndry_exchangev
  implicit none

  type (hybrid_t)      , intent(in) :: hybrid
  type (element_t)     , intent(inout), target :: elem(:)
  real (kind=real_kind), dimension(nv,nv,2,nlev,nets:nete)  :: vtens
  real (kind=real_kind), dimension(np,np,nlev,nets:nete) :: ptens
  type (EdgeBuffer_t)  , intent(inout) :: edge3
  type (derivative_t)  , intent(in) :: deriv
  real (kind=real_kind) :: dt2,pmean,real_time
  integer :: nm1,np1,n0,nets,nete

  ! local
  ! pointer ...
  real (kind=real_kind), dimension(:,:), pointer :: fcor,rspheremv,spheremv,metdet,rmetdetp
  real (kind=real_kind), dimension(:,:,:,:), pointer :: met,metinv
  real (kind=real_kind), dimension(nv,nv,2)    :: grade   ! strong kinetic energy gradient
  real (kind=real_kind), dimension(nv,nv,2)    :: pv      ! p*v lat-lon
  real (kind=real_kind), dimension(nv,nv)                     :: E          ! kinetic energy term
  real (kind=real_kind), dimension(nv,nv)                     :: zeta       ! relative vorticity
  real (kind=real_kind), dimension(nv,nv)      :: div  
  real (kind=real_kind), dimension(nv,nv,2)      :: ulatlon

  integer i,j,k,kptr,ie
  real (kind=real_kind) ::  v1,v2
  real (kind=real_kind) ::  vtens1,vtens2




  ! ===================================
  ! construct v tendencies and v.grad(p)
  ! on the velocity grid...
  ! ===================================
  do ie=nets,nete
     met    => elem(ie)%met
     metinv => elem(ie)%metinv
     metdet => elem(ie)%metdet
     rmetdetp => elem(ie)%rmetdetp
     fcor   => elem(ie)%fcor
     spheremv     => elem(ie)%spheremv

     call set_prescribed_velocity(elem(ie),n0,real_time)

     do k=1,nlev
        ! ==============================================
        ! Compute kinetic energy term
        ! ==============================================
        do j=1,nv
           do i=1,nv
              
              v1     = elem(ie)%state%v(i,j,1,k,n0)   ! contra
              v2     = elem(ie)%state%v(i,j,2,k,n0)   ! contra 
              ulatlon(i,j,1)=elem(ie)%D(1,1,i,j)*v1 + elem(ie)%D(1,2,i,j)*v2   ! contra->latlon
              ulatlon(i,j,2)=elem(ie)%D(2,1,i,j)*v1 + elem(ie)%D(2,2,i,j)*v2   ! contra->latlon
              
              E(i,j) = 0.5D0*(ulatlon(i,j,1)**2 + ulatlon(i,j,2)**2)  +&
                   elem(ie)%state%p(i,j,k,n0) + elem(ie)%state%ps(i,j)
              
              pv(i,j,1) = ulatlon(i,j,1)*(pmean+elem(ie)%state%p(i,j,k,n0))
              pv(i,j,2) = ulatlon(i,j,2)*(pmean+elem(ie)%state%p(i,j,k,n0))
           end do
        end do
        grade = gradient_sphere(E,deriv,elem(ie))       ! scalar -> latlon vector
        zeta = vorticity_sphere(ulatlon,deriv,elem(ie)) ! latlon vector -> scalar 
        div = divergence_sphere(pv,deriv,elem(ie))      ! latlon vector -> scalar 
        
        ! ==============================================
        ! Compute velocity tendency terms
        ! ==============================================
        do j=1,nv
           do i=1,nv
              ! accumulate strong form terms, apply mass matrix
              vtens(i,j,1,k,ie)=spheremv(i,j)*(ulatlon(i,j,2)*(fcor(i,j) + zeta(i,j))  - grade(i,j,1))
              vtens(i,j,2,k,ie)=spheremv(i,j)*(-ulatlon(i,j,1)*(fcor(i,j) + zeta(i,j)) - grade(i,j,2))
              ptens(i,j,k,ie) =  -spheremv(i,j)*div(i,j)
           end do
        end do
     end do
     
     ! ===================================================
     ! Pack cube edges of tendencies, rotate velocities
     ! ===================================================
     kptr=0
     call edgeVpack(edge3, ptens(1,1,1,ie),nlev,kptr,elem(ie)%desc)
     kptr=nlev
     call edgeVpack(edge3,vtens(1,1,1,1,ie),2*nlev,kptr,elem(ie)%desc)
  end do
  
  
  !$OMP BARRIER
  call bndry_exchangeV(hybrid,edge3)
  !$OMP BARRIER
  
  do ie=nets,nete
     rspheremv     => elem(ie)%rspheremv
     
     ! ===========================================================
     ! Unpack the edges for vgradp and vtens
     ! ===========================================================
     kptr=0
     call edgeVunpack(edge3, ptens(1,1,1,ie), nlev, kptr, elem(ie)%desc)
     
     kptr=nlev
     call edgeVunpack(edge3, vtens(1,1,1,1,ie), 2*nlev, kptr, elem(ie)%desc)
     
     ! ===========================================================
     ! Compute velocity and pressure tendencies for all levels
     ! ===========================================================
     do k=1,nlev
        do j=1,nv
           do i=1,nv
              ptens(i,j,k,ie) = rspheremv(i,j)*ptens(i,j,k,ie)
              vtens1=rspheremv(i,j)*vtens(i,j,1,k,ie)
              vtens2=rspheremv(i,j)*vtens(i,j,2,k,ie)
              
              ! lat-lon -> contra
              vtens(i,j,1,k,ie) = elem(ie)%Dinv(1,1,i,j)*vtens1 + elem(ie)%Dinv(1,2,i,j)*vtens2
              vtens(i,j,2,k,ie) = elem(ie)%Dinv(2,1,i,j)*vtens1 + elem(ie)%Dinv(2,2,i,j)*vtens2
           end do
        end do
     end do
     
     if (dt2/=0) then
     do k=1,nlev
        ! ====================================================
        ! Update
        ! ====================================================
        do j=1,nv
           do i=1,nv
              elem(ie)%state%v(i,j,1,k,np1) = elem(ie)%state%v(i,j,1,k,nm1) + dt2*vtens(i,j,1,k,ie)
              elem(ie)%state%v(i,j,2,k,np1) = elem(ie)%state%v(i,j,2,k,nm1) + dt2*vtens(i,j,2,k,ie)
              elem(ie)%state%p(i,j,k,np1) = elem(ie)%state%p(i,j,k,nm1) + dt2*ptens(i,j,k,ie)
           end do
        end do
     end do
     endif
  end do
  end subroutine compute_and_apply_rhs
  

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!-------------------------------------------------------------------
! c  Copyright (C) 1995, 1996, 1997, 1998
! c  Berwin A. Turlach <bturlach@stats.adelaide.edu.au>
! c  $Id: solve.QP.f,v 1.15 1998/07/23 05:23:26 bturlach Exp $
! c 
! c  This library is free software; you can redistribute it and/or
! c  modify it under the terms of the GNU Library General Public
! c  License as published by the Free Software Foundation; either
! c  version 2 of the License, or (at your option) any later version.
! c  
! c  This library is distributed in the hope that it will be useful,
! c  but WITHOUT ANY WARRANTY; without even the implied warranty of
! c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! c  Library General Public License for more details.
! c  
! c  You should have received a copy of the GNU Library General Public
! c  License along with this library; if not, write to the Free Software
! c  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
! c  MA 02111-1307 USA
! c 
! c  This routine uses the Goldfarb/Idnani algorithm to solve the
! c  following minimization problem:
! c
! c        minimize  -d^T x + 1/2 *  x^T D x
! c        where   A1^T x  = b1
! c                A2^T x >= b2
! c
! c  the matrix D is assumed to be positive definite.  Especially,
! c  w.l.o.g. D is assumed to be symmetric.
! c  
! c  Input parameter:
! c  dmat   nxn matrix, the matrix D from above (dp)
! c         *** WILL BE DESTROYED ON EXIT ***
! c         The user has two possibilities:
! c         a) Give D (ierr=0), in this case we use routines from LINPACK
! c            to decompose D.
! c         b) To get the algorithm started we need R^-1, where D=R^TR.
! c            So if it is cheaper to calculate R^-1 in another way (D may
! c            be a band matrix) then with the general routine, the user
! c            may pass R^{-1}.  Indicated by ierr not equal to zero.
! c  dvec   nx1 vector, the vector d from above (dp)
! c         *** WILL BE DESTROYED ON EXIT ***
! c         contains on exit the solution to the initial, i.e.,
! c         unconstrained problem
! c  fddmat scalar, the leading dimension of the matrix dmat
! c  n      the dimension of dmat and dvec (int)
! c  amat   nxq matrix, the matrix A from above (dp) [ A=(A1 A2) ]
! c         *** ENTRIES CORRESPONDING TO EQUALITY CONSTRAINTS MAY HAVE
! c             CHANGED SIGNES ON EXIT ***
! c  bvec   qx1 vector, the vector of constants b in the constraints (dp)
! c         [ b = (b1^T b2^T)^T ]
! c         *** ENTRIES CORRESPONDING TO EQUALITY CONSTRAINTS MAY HAVE
! c             CHANGED SIGNES ON EXIT ***
! c  fdamat the first dimension of amat as declared in the calling program. 
! c         fdamat >= n !!
! c  q      integer, the number of constraints.
! c  meq    integer, the number of equality constraints, 0 <= meq <= q.
! c  ierr   integer, code for the status of the matrix D:
! c            ierr =  0, we have to decompose D
! c            ierr != 0, D is already decomposed into D=R^TR and we were
! c                       given R^{-1}.
! c
! c  Output parameter:
! c  sol   nx1 the final solution (x in the notation above)
! c  crval scalar, the value of the criterion at the minimum      
! c  iact  qx1 vector, the constraints which are active in the final
! c        fit (int)
! c  nact  scalar, the number of constraints active in the final fit (int)
! c  iter  2x1 vector, first component gives the number of "main" 
! c        iterations, the second one says how many constraints were
! c        deleted after they became active
! c  ierr  integer, error code on exit, if
! c           ierr = 0, no problems
! c           ierr = 1, the minimization problem has no solution
! c           ierr = 2, problems with decomposing D, in this case sol
! c                     contains garbage!!
! c
! c  Working space:
! c  work  vector with length at least 2*n+r*(r+5)/2 + 2*q +1
! c        where r=min(n,q)
! c
      subroutine qpgen2(dmat, dvec, fddmat, n, sol, crval, amat, &
          bvec, fdamat, q, meq, iact, nact, iter, work, ierr, maxit)  
      implicit none
      integer n, i, j, l, l1, fdamat, fddmat, &
          info, q, iact(*), iter(*), it1,    &
          ierr, nact, iwzv, iwrv, iwrm, iwsv, iwuv, nvl,   &
          r, iwnbv, meq, maxit
      double precision dmat(fddmat,*), dvec(*),sol(*), bvec(*), &
          work(*), temp, sum, t1, tt, gc, gs, crval, &
          nu, amat(fdamat,*)
      logical t1inf, t2min
      r = min(n,q)
      l = 2*n + (r*(r+5))/2 + 2*q + 1

      do 10 i=1,n
         work(i) = dvec(i)
 10   continue
      do 11 i=n+1,l
         work(i) = 0.d0
 11   continue
      do 12 i=1,q
         iact(i)=0
 12   continue

      if( ierr .EQ. 0 )then

         call dpofa(dmat,fddmat,n,info)

         if( info .NE. 0 )then
            ierr = 2
            goto 999
         endif
         call dposl(dmat,fddmat,n,dvec)
         call dpori(dmat,fddmat,n)
      else

         do 20 j=1,n
            sol(j)  = 0.d0
            do 21 i=1,j
               sol(j) = sol(j) + dmat(i,j)*dvec(i)
 21         continue
 20      continue
         do 22 j=1,n
            dvec(j) = 0.d0
            do 23 i=j,n
               dvec(j) = dvec(j) + dmat(j,i)*sol(i)
 23         continue
 22      continue
      endif

      crval = 0.d0   
      do 30 j=1,n
         sol(j)  = dvec(j)
         crval   = crval + work(j)*sol(j)
         work(j) = 0.d0
         do 32 i=j+1,n
            dmat(i,j) = 0.d0
 32      continue
 30   continue
      crval = -crval/2.d0
      ierr = 0

      iwzv  = n
      iwrv  = iwzv + n
      iwuv  = iwrv + r
      iwrm  = iwuv + r+1
      iwsv  = iwrm + (r*(r+1))/2
      iwnbv = iwsv + q

      do 51 i=1,q
         sum = 0.d0
         do 52 j=1,n
            sum = sum + amat(j,i)*amat(j,i)
 52      continue
         work(iwnbv+i) = sqrt(sum)
 51   continue
      nact = 0
      iter(1) = 0
      iter(2) = 0
 50   continue



      iter(1) = iter(1)+1

      if(iter(1)>maxit)then
         ierr=3
         goto 999
      endif



      l = iwsv
      do 60 i=1,q
         l = l+1
         sum = -bvec(i)
         do 61 j = 1,n
            sum = sum + amat(j,i)*sol(j)
 61      continue
         if (i .GT. meq) then
            work(l) = sum
         else
            work(l) = -abs(sum)
            if (sum .GT. 0.d0) then
               do 62 j=1,n
                  amat(j,i) = -amat(j,i)
 62            continue
               bvec(i) = -bvec(i)
            endif
         endif
 60   continue

      do 70 i=1,nact
         work(iwsv+iact(i)) = 0.d0
 70   continue

      nvl = 0 
      temp = 0.d0
      do 71 i=1,q
         if (work(iwsv+i) .LT. temp*work(iwnbv+i)) then
            nvl = i
            temp = work(iwsv+i)/work(iwnbv+i)
         endif

 71   continue
 72   if (nvl .EQ. 0) goto 999

 55   continue
      do 80 i=1,n
         sum = 0.d0
         do 81 j=1,n
            sum = sum + dmat(j,i)*amat(j,nvl)
 81      continue
         work(i) = sum
 80   continue

      l1 = iwzv
      do 90 i=1,n
         work(l1+i) =0.d0
 90   continue
      do 92 j=nact+1,n
         do 93 i=1,n
            work(l1+i) = work(l1+i) + dmat(i,j)*work(j) 
 93      continue
 92   continue

      t1inf = .TRUE.
      do 95 i=nact,1,-1
         sum = work(i)
         l  = iwrm+(i*(i+3))/2
         l1 = l-i
         do 96 j=i+1,nact
            sum = sum - work(l)*work(iwrv+j)
            l   = l+j
 96      continue
         sum = sum / work(l1)
         work(iwrv+i) = sum
         if (iact(i) .LE. meq) goto 95
         if (sum .LE. 0.d0) goto 95
 7       t1inf = .FALSE.
         it1 = i
 95   continue
 
      if ( .NOT. t1inf) then
         t1   = work(iwuv+it1)/work(iwrv+it1)
         do 100 i=1,nact
            if (iact(i) .LE. meq) goto 100
            if (work(iwrv+i) .LE. 0.d0) goto 100
            temp = work(iwuv+i)/work(iwrv+i)
            if (temp .LT. t1) then
               t1   = temp
               it1  = i
            endif
 100     continue
      endif 

      sum = 0.d0
      do 110 i=iwzv+1,iwzv+n
         sum = sum + work(i)*work(i)
 110  continue
      temp = 1000.d0
      sum  = sum+temp
      if (temp .EQ. sum) then
     
         if (t1inf) then

            ierr = 1
            goto 999
         else

            do 111 i=1,nact
               work(iwuv+i) = work(iwuv+i) - t1*work(iwrv+i)
 111        continue
            work(iwuv+nact+1) = work(iwuv+nact+1) + t1
            goto 700
         endif
      else

         sum = 0.d0
         do 120 i = 1,n
            sum = sum + work(iwzv+i)*amat(i,nvl)
 120     continue
         tt = -work(iwsv+nvl)/sum
         t2min = .TRUE.
         if (.NOT. t1inf) then
            if (t1 .LT. tt) then
               tt    = t1
               t2min = .FALSE.
            endif
         endif

         do 130 i=1,n
            sol(i) = sol(i) + tt*work(iwzv+i)
 130     continue
         crval = crval + tt*sum*(tt/2.d0 + work(iwuv+nact+1))
         do 131 i=1,nact
            work(iwuv+i) = work(iwuv+i) - tt*work(iwrv+i)
 131     continue
         work(iwuv+nact+1) = work(iwuv+nact+1) + tt

         if(t2min) then

            nact = nact + 1
            iact(nact) = nvl

            l = iwrm + ((nact-1)*nact)/2 + 1
            do 150 i=1,nact-1
               work(l) = work(i)
               l = l+1
 150        continue

            if (nact .EQ. n) then
               work(l) = work(n)
            else
               do 160 i=n,nact+1,-1

                  if (work(i) .EQ. 0.d0) goto 160
                  gc   = max(abs(work(i-1)),abs(work(i)))
                  gs   = min(abs(work(i-1)),abs(work(i)))
                  temp = sign(gc*sqrt(1+gs*gs/(gc*gc)), work(i-1))
                  gc   = work(i-1)/temp
                  gs   = work(i)/temp

                  if (gc .EQ. 1.d0) goto 160
                  if (gc .EQ. 0.d0) then
                     work(i-1) = gs * temp
                     do 170 j=1,n
                        temp        = dmat(j,i-1)
                        dmat(j,i-1) = dmat(j,i)
                        dmat(j,i)   = temp
 170                 continue
                  else
                     work(i-1) = temp
                     nu = gs/(1.d0+gc)
                     do 180 j=1,n
                        temp        = gc*dmat(j,i-1) + gs*dmat(j,i)
                        dmat(j,i)   = nu*(dmat(j,i-1)+temp) - dmat(j,i)
                        dmat(j,i-1) = temp
 180                 continue
                  endif
 160           continue

               work(l) = work(nact)
            endif
         else

            sum = -bvec(nvl)
            do 190 j = 1,n
               sum = sum + sol(j)*amat(j,nvl)
 190        continue
            if( nvl .GT. meq ) then
               work(iwsv+nvl) = sum
            else
               work(iwsv+nvl) = -abs(sum)
               if( sum .GT. 0.d0) then
                  do 191 j=1,n
                     amat(j,nvl) = -amat(j,nvl)
 191              continue
               bvec(i) = -bvec(i)
               endif
            endif
            goto 700
         endif
      endif
      goto 50

 700  continue

      if (it1 .EQ. nact) goto 799

 797  continue

      l  = iwrm + (it1*(it1+1))/2 + 1
      l1 = l+it1
      if (work(l1) .EQ. 0.d0) goto 798
      gc   = max(abs(work(l1-1)),abs(work(l1)))
      gs   = min(abs(work(l1-1)),abs(work(l1)))
      temp = sign(gc*sqrt(1+gs*gs/(gc*gc)), work(l1-1))
      gc   = work(l1-1)/temp
      gs   = work(l1)/temp

      if (gc .EQ. 1.d0) goto 798
      if (gc .EQ. 0.d0) then
         do 710 i=it1+1,nact
            temp       = work(l1-1)
            work(l1-1) = work(l1)
            work(l1)   = temp
            l1 = l1+i
 710     continue
         do 711 i=1,n
            temp          = dmat(i,it1)
            dmat(i,it1)   = dmat(i,it1+1)
            dmat(i,it1+1) = temp
 711     continue
      else
         nu = gs/(1.d0+gc)
         do 720 i=it1+1,nact
            temp       = gc*work(l1-1) + gs*work(l1)
            work(l1)   = nu*(work(l1-1)+temp) - work(l1)
            work(l1-1) = temp
            l1 = l1+i
 720     continue
         do 721 i=1,n
            temp          = gc*dmat(i,it1) + gs*dmat(i,it1+1)
            dmat(i,it1+1) = nu*(dmat(i,it1)+temp) - dmat(i,it1+1)
            dmat(i,it1)   = temp
 721     continue
      endif

 798  continue
      l1 = l-it1
      do 730 i=1,it1
         work(l1)=work(l)
         l  = l+1
         l1 = l1+1
 730  continue

      work(iwuv+it1) = work(iwuv+it1+1)
      iact(it1)      = iact(it1+1)
      it1 = it1+1
      if (it1 .LT. nact) goto 797
 799  work(iwuv+nact)   = work(iwuv+nact+1)
      work(iwuv+nact+1) = 0.d0
      iact(nact)        = 0
      nact = nact-1
      iter(2) = iter(2)+1
      goto 55
 999  continue
      return
      end subroutine qpgen2



!-------------------------------------------------------------------
      subroutine dpori(a,lda,n)
      integer lda,n
      double precision a(lda,1)

      double precision t
      integer j,k,kp1
      do 100 k = 1, n
         a(k,k) = 1.0d0/a(k,k)
         t = -a(k,k)
         call dscal(k-1,t,a(1,k),1)
         kp1 = k + 1
         if (n .lt. kp1) go to 90
         do 80 j = kp1, n
            t = a(k,j)
            a(k,j) = 0.0d0
            call daxpy(k,t,a(1,k),1,a(1,j),1)
 80      continue
 90      continue
 100  continue
      return
      end  subroutine dpori
 
!-------------------------------------------------------------------

      subroutine dposl(a,lda,n,b)
      integer lda,n
      double precision a(lda,1),b(1)

      double precision ddot,t
      integer k,kb
      do 10 k = 1, n
         t = ddot(k-1,a(1,k),1,b(1),1)
         b(k) = (b(k) - t)/a(k,k)
   10 continue

      do 20 kb = 1, n
         k = n + 1 - kb
         b(k) = b(k)/a(k,k)
         t = -b(k)
         call daxpy(k-1,t,a(1,k),1,b(1),1)
   20 continue

      return
      end subroutine dposl


!-------------------------------------------------------------------
      SUBROUTINE DPOFA (A, LDA, N, INFO)

      INTEGER LDA,N,INFO
      DOUBLE PRECISION A(LDA,*)

      DOUBLE PRECISION DDOT,T
      DOUBLE PRECISION S
      INTEGER J,JM1,K

         DO 30 J = 1, N
            INFO = J
            S = 0.0D0
            JM1 = J - 1
            IF (JM1 .LT. 1) GO TO 20
            DO 10 K = 1, JM1
               T = A(K,J) - DDOT(K-1,A(1,K),1,A(1,J),1)
               T = T/A(K,K)
               A(K,J) = T
               S = S + T*T
   10       CONTINUE
   20       CONTINUE
            S = A(J,J) - S
            IF (S .LE. 0.0D0) GO TO 40
            A(J,J) = SQRT(S)
   30    CONTINUE
         INFO = 0
   40 CONTINUE
      RETURN
      END SUBROUTINE DPOFA
!-----------------------------------------------------------------




end module advance_mod
