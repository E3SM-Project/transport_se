module interp_movie_mod
  use kinds, only : real_kind
  use dimensions_mod, only :  nlev, nelemd, np, nv, ne, qsize
  use interpolate_mod, only : interpolate_t, setup_latlon_interp, interpdata_t, &
       get_interp_parameter, get_interp_lat, get_interp_lon, interpolate_scalar, interpolate_vector, &
       set_interp_parameter
  use pio_io_mod, only : &
       nf_output_init_begin,&
       nf_output_init_complete,  &
       nf_output_register_variables,&
       nf_put_var, &
       nf_close_all, &
       nf_output_register_dims, &
       nf_selectedvar, &
       nf_advance_frame, &
       nf_handle, &
       get_current_varnames, &
       nf_variable_attributes, &
       nfsizekind,             &
       nf_get_frame,           &
       PIO_double,              &
       nf_init_decomp, &
       get_varindex

  use control_mod, only : test_case, runtype, accumstart, &
       accumstop, accumfreq, restartfreq, &
       integration, columnpackage
  use common_io_mod, only:  &
       output_start_time,   & 	
       output_end_time,     &
       output_frequency,    &
       output_dir,          &
       max_output_variables,&
       max_output_streams,  &
       varname_len,         &
       nf_addrequiredvar,   &
       num_io_procs,        &
       PIOFS

  implicit none
#ifdef _PRIM
  integer, parameter :: varcnt = 30
  integer, parameter :: maxdims =  5
  character*(*), parameter :: varnames(varcnt)=(/'ps    ', &
                                                 'geos  ', &
                                                 'zeta  ', &
                                                 'T     ', &
                                                 'Th    ', &
                                                 'u     ', &
                                                 'v     ', &
                                                 'ke    ', &
                                                 'Q     ', &
                                                 'Q2    ', &
                                                 'Q3    ', &
                                                 'Q4    ', &
                                                 'geo   ', &
                                                 'omega ', &
                                                 'FU    ', &
                                                 'FV    ', &
                                                 'DIFFU ', &
                                                 'DIFFV ', &
                                                 'CONVU ', &
                                                 'CONVV ', &
                                                 'lat   ', &
                                                 'lon   ', &
                                                 'gw    ', &
                                                 'lev   ', &
                                                 'ilev  ', &
                                                 'hyam  ', &
                                                 'hybm  ', &
                                                 'hyai  ', &
                                                 'hybi  ', &
                                                 'time  '/)
  integer, parameter :: vartype(varcnt)=(/PIO_double, PIO_double,PIO_double,PIO_double,&
                                          PIO_double, PIO_double,PIO_double,PIO_double,&
                                          PIO_double, PIO_double,PIO_double,PIO_double,&
                                          PIO_double, PIO_double,PIO_double,PIO_double,&
                                          PIO_double, PIO_double,PIO_double,PIO_double,&
                                          PIO_double, PIO_double,&
                                          PIO_double, PIO_double,&
                                          PIO_double, PIO_double,&
                                          PIO_double, PIO_double,&
                                          PIO_double, PIO_double/)
  logical, parameter :: varrequired(varcnt)=(/.false.,.false.,.false.,.false.,.false.,&
                                              .false.,.false.,.false.,.false.,.false.,&
                                              .false.,.false.,&
                                              .false.,.false.,&
                                              .false.,.false.,&
                                              .false.,.false.,&
                                              .false.,.false.,.true. ,.true. ,&
                                              .false.,.true. ,.true. ,&   ! gw,lev,ilev
                                              .true. ,.true. ,&   ! hy arrays
                                              .true. ,.true. ,&   ! hy arrays
                                              .true./)

  integer, parameter :: vardims(maxdims,varcnt) =  reshape( (/ 1,2,5,0,0,  &
       1,2,0,0,0,  &   ! geos
       1,2,3,5,0,  &   ! zeta
       1,2,3,5,0,  &   ! T
       1,2,3,5,0,  &   ! Th
       1,2,3,5,0,  &   ! u
       1,2,3,5,0,  &   ! v
       1,2,3,5,0,  &   ! ke
       1,2,3,5,0,  &   ! Q
       1,2,3,5,0,  &   ! Q2
       1,2,3,5,0,  &   ! Q3
       1,2,3,5,0,  &   ! Q4
       1,2,3,5,0,  &   ! geo
       1,2,3,5,0,  &   ! omega
       1,2,3,5,0,  &   ! FU
       1,2,3,5,0,  &   ! FV
       1,2,3,5,0,  &   ! DIFFU
       1,2,3,5,0,  &   ! DIFFV
       1,2,3,5,0,  &   ! CONVU
       1,2,3,5,0,  &   ! CONVV
       2,0,0,0,0,  &   ! lat
       1,0,0,0,0,  &   ! lon
       2,0,0,0,0,  &   ! gw
       3,0,0,0,0,  &   ! lev
       4,0,0,0,0,  &   ! ilev
       3,0,0,0,0,  &   ! hyam
       3,0,0,0,0,  &   ! hybm
       4,0,0,0,0,  &   ! hyai
       4,0,0,0,0,  &   ! hybi
       5,0,0,0,0 /),&
       shape=(/maxdims,varcnt/))

  character*(*),parameter::dimnames(maxdims)=(/'lon ','lat ','lev ','ilev','time'/)  
#else
  integer, parameter :: varcnt = 9
  integer, parameter :: maxdims=4
  character*(*),parameter::dimnames(maxdims)=(/'lon ','lat ','lev ','time'/)  
  integer, parameter :: vardims(maxdims,varcnt) =  reshape( (/ 1,2,4,0,  &
                                                               1,2,3,4,  &
                                                               1,2,3,4,  &
                                                               1,2,3,4,  &
                                                               1,2,3,4,  &
                                                               1,0,0,0,  &
                                                               2,0,0,0,  &
                                                               2,0,0,0,  &
                                                               4,0,0,0/),&
                                                               shape=(/maxdims,varcnt/))
  character*(*),parameter::varnames(varcnt)=(/'ps   ','geop ','u    ','v    ',&
                                              'zeta ','lon  ','lat  ','gw   ','time ' /)
  integer, parameter :: vartype(varcnt)=(/PIO_double,PIO_double,PIO_double,PIO_double,PIO_double,&
                                          PIO_double, PIO_double, PIO_double,PIO_double/)
  logical, parameter :: varrequired(varcnt)=(/.false.,.false.,.false.,.false.,&
                                              .false.,.true.,.true.,.false.,.true./)

#endif
  type(interpolate_t) :: interp
  type(interpdata_t), allocatable :: interpdata(:)

  integer(kind=nfsizekind) :: start2d(3), count2d(3), start3d(4), count3d(4)
  type(nf_handle) :: ncdf(max_output_streams)

contains
  subroutine interp_movie_init(elem,hybrid,nets,nete,hvcoord,tl)
    use time_mod, only : timelevel_t
    use hybrid_mod, only : hybrid_t
    use element_mod, only: element_t
    use pio, only : pio_setdebuglevel, PIO_Put_att, pio_put_var, pio_global
    use parallel_mod, only : parallel_t, haltmp, syncmp
    use interpolate_mod, only : get_interp_lat, get_interp_lon, get_interp_gweight
#ifdef _PRIM
	use hybvcoord_mod, only : hvcoord_t
#ifndef CAM
    use aquaplanet_io_mod, only : aq_movie_init
    use physics_io_mod, only : physics_movie_init
#endif
#endif

    type (TimeLevel_t), intent(in)         :: tl     ! time level struct
    type(element_t) :: elem(:)
    type(hybrid_t), target  :: hybrid
#ifdef _PRIM
    type(hvcoord_t), intent(in), optional :: hvcoord
#else
    ! ignored
    integer, optional :: hvcoord
#endif
    integer, intent(in) :: nets, nete
    integer :: dimsize(maxdims)   
    integer, pointer :: ldof2d(:),ldof3d(:), iodof2d(:), iodof3d(:)
    integer, pointer :: latdof(:), londof(:), iodoflon(:), iodoflat(:)

    integer :: icnt, i, k, lcount, iorank, nlat, nlon, tdof(1), tiodof(1), ios, ie
    type(parallel_t), pointer :: par
    integer(kind=nfsizekind) :: start1d(1), count1d(1)
    real(kind=real_kind), allocatable :: lat(:), lon(:), gw(:)
    real(kind=real_kind), allocatable :: lev(:),ilev(:)
    integer :: varid, vindex
    integer :: ierr
    character(len=9)     :: charnum
    character(len=90)    :: hname

    allocate(interpdata(nelemd))

    call setup_latlon_interp(elem,interpdata, hybrid, nets, nete)

    lcount = sum(interpdata(nets:nete)%n_interp)
    par => hybrid%par

    nlat = get_interp_parameter('nlat')
    nlon = get_interp_parameter('nlon')


    if (runtype==0) then
       hname = test_case
    else
       ! restart runs (1) or (2)
       write(charnum,'(i9.9)') tl%nstep
       hname = trim(ADJUSTL(test_case)) // "-" // charnum //"-"
    endif

    call PIO_setDebugLevel(0)
    call nf_output_init_begin(ncdf,par%masterproc,par%nprocs,par%rank, &
         par%comm,hname,runtype)
#ifdef _PRIM
    dimsize=(/nlon,nlat,nlev,nlev+1,0/)
#else
    dimsize=(/nlon,nlat,nlev,0/)
#endif
    call nf_output_register_dims(ncdf, maxdims, dimnames, dimsize)
    if (2 == get_interp_parameter('gridtype')) then
       call nf_addrequiredvar(ncdf,'gw')
    end if

    iorank=piofs%io_rank

    ! Create the DOF arrays
    allocate(ldof2d(lcount))
    allocate(ldof3d(lcount*nlev))
    icnt=0
    do ie=nets,nete
       do i=1,interpdata(ie)%n_interp
          icnt=icnt+1
          ldof2d(icnt)=interpdata(ie)%ilon(i)+(interpdata(ie)%ilat(i)-1)*nlon
       end do
    end do
    icnt=0
    do k=1,nlev
       do ie=nets,nete
          do i=1,interpdata(ie)%n_interp
             icnt=icnt+1
             ldof3d(icnt)=interpdata(ie)%ilon(i)+(interpdata(ie)%ilat(i)-1)*nlon+(k-1)*nlat*nlon
          end do
       end do
    end do
    call getiodof(2, (/nlon,nlat/), iorank, iodof2d, start2d(1:2), count2d(1:2))

    call nf_init_decomp(ncdf, (/1,2/), ldof2d, iodof2d,start2d(1:2),count2d(1:2))

    call getiodof(3, (/nlon,nlat,nlev/), iorank, iodof3d, start3d(1:3), count3d(1:3))

    call nf_init_decomp(ncdf, (/1,2,3/), ldof3d, iodof3d,start3d(1:3),count3d(1:3))

    deallocate(iodof2d, iodof3d, ldof2d,ldof3d)

    ! this is a trivial case for the time variable
    if(iorank==0) then
       tdof(1)=1
       tiodof(1)=1
    else		    	
       tdof(1)=0
       tiodof(1)=0
    end if
    start1d=-1
    count1d=-1
#ifdef _PRIM
    call nf_init_decomp(ncdf,(/5/), tdof,tiodof,start1d,count1d)
#else
    call nf_init_decomp(ncdf,(/4/), tdof,tiodof,start1d,count1d)
#endif
#ifdef OLDWAY
    ! this is a trivial case for the lat/lon variable
    call getiodof(1,(/nlon/), iorank, iodof2d, start1d, count1d)
    if(iorank.eq.0) then
       allocate(londof(nlon), latdof(nlat))
       do i=1,nlon
          londof(i)=i
       end do
       do i=1,nlat
          latdof(i)=i
       end do
    else
       allocate(londof(1), latdof(1))
    end if
    call nf_init_decomp(ncdf,(/1/), londof,iodof2d,start1d,count1d)
    deallocate(londof,iodof2d)

    call getiodof(1,(/nlat/), iorank, iodof2d, start1d, count1d)
    call nf_init_decomp(ncdf,(/2/), latdof,iodof2d,start1d,count1d)
    deallocate(latdof,iodof2d)
#endif
#ifdef _PRIM
    if (present(hvcoord)) then
#ifdef OLDWAY
       ! this is a trivial case for the lev/ilev variable
       call getiodof(1,(/nlev+1/), iorank, iodof2d, start1d, count1d)
       if(iorank.eq.0) then
          allocate(londof(nlev+1), latdof(nlev))
          do i=1,nlev+1
             londof(i)=i
          end do
          do i=1,nlev
             latdof(i)=i
          end do
       else
          allocate(londof(1), latdof(1))
       end if
       call nf_init_decomp(ncdf,(/4/), londof,iodof2d,start1d,count1d)
       deallocate(londof,iodof2d)

       call getiodof(1,(/nlev/), iorank, iodof2d, start1d, count1d)
       call nf_init_decomp(ncdf,(/3/), latdof,iodof2d,start1d,count1d)
       deallocate(latdof,iodof2d)
#endif
    endif
#endif

    call nf_output_register_variables(ncdf,varcnt,varnames,vardims,vartype,varrequired)
    do ios = 1, max_output_streams
       if((output_frequency(ios) .gt. 0) ) then
          i=PIO_Put_att(ncdf(ios)%fileid,pio_global,'nv',nv)
          i=PIO_Put_att(ncdf(ios)%fileid,pio_global,'ne',ne)
       endif
    enddo
    !call nf_global_attribute(ncdf, 'nv', nv)
    !call nf_global_attribute(ncdf, 'ne', ne)

    call nf_variable_attributes(ncdf, 'ps', 'surface pressure','Pa')
    call nf_variable_attributes(ncdf, 'u', 'longitudinal wind component','meters/second')
    call nf_variable_attributes(ncdf, 'v', 'latitudinal wind component','meters/second')
    call nf_variable_attributes(ncdf, 'zeta', 'Relative vorticity','1/s')
#ifdef _PRIM
    call nf_variable_attributes(ncdf, 'geo', 'Geopotential','m^2/s^2')
    call nf_variable_attributes(ncdf, 'geos', 'Surface geopotential','m^2/s^2')
    call nf_variable_attributes(ncdf, 'T', 'Temperature','degrees kelvin')
    call nf_variable_attributes(ncdf, 'Q', 'concentration','kg/kg')
    call nf_variable_attributes(ncdf, 'Q2', 'concentration','kg/kg')
    call nf_variable_attributes(ncdf, 'Q3', 'concentration','kg/kg')
    call nf_variable_attributes(ncdf, 'Q4', 'concentration','kg/kg')
    call nf_variable_attributes(ncdf, 'lev' ,'hybrid level at midpoints' ,'level','positive','down') !,'formula_terms','a: hyam b: hybm p0: P0 ps: PS')
    call nf_variable_attributes(ncdf, 'ilev','hybrid level at interfaces','level','positive','down') !,'formula_terms','a: hyai b: hybi p0: P0 ps: PS')
    call nf_variable_attributes(ncdf, 'hyam','hybrid A coefficiet at layer midpoints' ,'dimensionless') 
    call nf_variable_attributes(ncdf, 'hybm','hybrid B coefficiet at layer midpoints' ,'dimensionless') 
    call nf_variable_attributes(ncdf, 'hyai','hybrid A coefficiet at layer interfaces' ,'dimensionless') 
    call nf_variable_attributes(ncdf, 'hybi','hybrid B coefficiet at layer interfaces' ,'dimensionless') 
#endif
    if (2 == get_interp_parameter('gridtype')) then
       call nf_variable_attributes(ncdf, 'gw', 'gauss weights','dimensionless')
    end if
    call nf_variable_attributes(ncdf, 'lat', 'column latitude','degrees_north')
    call nf_variable_attributes(ncdf, 'lon', 'column longitude','degrees_east')
    call nf_variable_attributes(ncdf, 'time', 'Model elapsed time','days')

#ifdef _PRIM
#ifndef CAM 
    if(test_case.eq.'aquaplanet') then
       call aq_movie_init(ncdf)
    end if
    if(columnpackage.ne.'none') then
       call physics_movie_init(ncdf)
    end if
#endif
#endif
    call nf_output_init_complete(ncdf)
    if(iorank.eq.0) then
       allocate(lon(nlon), lat(nlat), gw(nlat))
       allocate(lev(nlev), ilev(nlev+1))
       lon = get_interp_lon()
       lat = get_interp_lat()
    else
       allocate(lon(1), lat(1), gw(1))
       allocate(lev(1), ilev(1))  ! non iorank==0 process must make call with dummy array of size 1
    end if

    do ios=1,max_output_streams
       if((output_frequency(ios) .gt. 0) ) then
          if(iorank==0) print *,"writing coordinates to ios=",ios
#ifdef OLDWAY
	  start1d=1
          count1d=0	
          if(iorank.eq.0) then
             count1d(1)=nlon
          end if
          if(iorank==0) print *,"lon"
          call nf_put_var(ncdf(ios),lon,start1d,count1d,name='lon')

          if(iorank.eq.0) then
             count1d(1)=nlat
          end if
          if(iorank==0) print *,"lat"
          call nf_put_var(ncdf(ios),lat,start1d,count1d,name='lat')

          if (2 == get_interp_parameter('gridtype')) then
             ! output gauss weights
             if(iorank==0) print *,"gw"
             call nf_put_var(ncdf(ios),gw,start1d,count1d,name='gw')
          endif
#else
        vindex = get_varindex('lon',ncdf(ios)%varlist)
        varid = ncdf(ios)%varlist(vindex)%vardesc%varid
	ierr = pio_put_var(ncdf(ios)%FileID,varid, lon)
        vindex = get_varindex('lat',ncdf(ios)%varlist)
        varid = ncdf(ios)%varlist(vindex)%vardesc%varid
	ierr = pio_put_var(ncdf(ios)%FileID,varid, lat)

        if (2 == get_interp_parameter('gridtype')) then
           ! output gauss weights
           if(iorank==0) gw = get_interp_gweight()
           vindex = get_varindex('gw',ncdf(ios)%varlist)
           varid = ncdf(ios)%varlist(vindex)%vardesc%varid
           ierr = pio_put_var(ncdf(ios)%FileID,varid, gw)
        endif

#endif
#ifdef _PRIM
          if (present(hvcoord)) then
#ifdef OLDWAY
             if(iorank.eq.0) then
                lev = hvcoord%etam
                count1d(1)=nlev
             end if
             if(iorank==0) print *,"lev"
             call nf_put_var(ncdf(ios),lev,start1d,count1d,name='lev')

             if(iorank.eq.0) lev = hvcoord%hyam
             if(iorank==0) print *,"hyam"
             call nf_put_var(ncdf(ios),lev,start1d,count1d,name='hyam')
             if(iorank.eq.0) lev = hvcoord%hybm
             if(iorank==0) print *,"hybm"
             call nf_put_var(ncdf(ios),lev,start1d,count1d,name='hybm')


             if(iorank.eq.0) then
                count1d(1)=nlev+1
                ilev = hvcoord%etai
             end if
             if(iorank==0) print *,"ilev"
             call nf_put_var(ncdf(ios),ilev,start1d,count1d,name='ilev')

             if(iorank.eq.0) ilev = hvcoord%hyai
             if(iorank==0) print *,"hyai"
             call nf_put_var(ncdf(ios),ilev,start1d,count1d,name='hyai')
             if(iorank.eq.0) ilev = hvcoord%hybi
             if(iorank==0) print *,"hybi"
             call nf_put_var(ncdf(ios),ilev,start1d,count1d,name='hybi')
#else
             vindex = get_varindex('lev',ncdf(ios)%varlist)
             varid = ncdf(ios)%varlist(vindex)%vardesc%varid
             ierr = pio_put_var(ncdf(ios)%FileID,varid, hvcoord%etam)

             vindex = get_varindex('hyam',ncdf(ios)%varlist)
             varid = ncdf(ios)%varlist(vindex)%vardesc%varid
             ierr = pio_put_var(ncdf(ios)%FileID,varid, hvcoord%hyam)

             vindex = get_varindex('hybm',ncdf(ios)%varlist)
             varid = ncdf(ios)%varlist(vindex)%vardesc%varid
             ierr = pio_put_var(ncdf(ios)%FileID,varid, hvcoord%hybm)

             vindex = get_varindex('hyai',ncdf(ios)%varlist)
             varid = ncdf(ios)%varlist(vindex)%vardesc%varid
             ierr = pio_put_var(ncdf(ios)%FileID,varid, hvcoord%hyai)

             vindex = get_varindex('hybi',ncdf(ios)%varlist)
             varid = ncdf(ios)%varlist(vindex)%vardesc%varid
             ierr = pio_put_var(ncdf(ios)%FileID,varid, hvcoord%hybi)

#endif
          end if
#endif
       endif
    end do

    deallocate(lat,lon,gw)
    deallocate(lev,ilev)
    call syncmp(par)

  end subroutine interp_movie_init

  subroutine interp_movie_finish
    call nf_close_all(ncdf)
  end subroutine interp_movie_finish

#ifdef _PRIM
  subroutine interp_movie_output(elem, tl, hvcoord, hybrid, nets,nete)
#else
  subroutine interp_movie_output(elem, tl, hybrid, phimean, deriv, nets,nete)
#endif
    use kinds, only : int_kind, real_kind
    use element_mod, only : element_t
    use time_mod, only : Timelevel_t, tstep, ndays, time_at, secpday, nendstep,nmax
    use parallel_mod, only : parallel_t, abortmp
#ifdef _PRIM
    use hybvcoord_mod, only :  hvcoord_t 
    use physical_constants, only : g, kappa, p0
#ifndef CAM
    use aquaplanet_io_mod, only : aq_movie_output
    use physics_io_mod, only : physics_movie_output
#endif
#else
    use derivative_mod, only : derivative_t, vorticity
    use physical_constants, only : omega, g, rearth, dd_pi
#endif
    use hybrid_mod, only : hybrid_t
! get rid of this ifdef as soon as HOMME updates to > pio24_prod
#define PIOSYNC
#ifdef PIOSYNC
    use pio, only : pio_setdebuglevel, pio_syncfile
#else
    use pio, only : pio_setdebuglevel
#endif

    use viscosity_mod, only : compute_zeta_C0, make_c0
    use perf_mod, only : t_startf, t_stopf
    ! ---------------------    
    type (element_t)    :: elem(:)
    type (TimeLevel_t)  :: tl
    type (parallel_t)     :: par
#ifdef _PRIM
    type (hvcoord_t)    :: hvcoord
#else
    real (kind=real_kind), intent(in) :: phimean
    type (derivative_t),intent(in)  :: deriv
#endif
    type (hybrid_t)      , intent(in) :: hybrid
    integer              :: nets,nete

    character(len=varname_len), pointer :: output_varnames(:)
    integer :: ie,ios, i, j, k
    real (kind=real_kind) :: pfull, pr0
    real(kind=real_kind),parameter :: dayspersec=1d0/(3600.*24.)
    real(kind=real_kind), allocatable :: datall(:,:), var3d(:,:,:,:)
    
    integer :: st, en

    integer :: ierr

    integer :: ncnt,n0,n0q,itype,pcord,ii

    real (kind=real_kind), dimension(nv,nv,2) :: vco 
    real (kind=real_kind) :: v1,v2,rdx,rdy,dx,dy,lenscale

    call t_startf('interp_movie_output')

    n0 = tl%n0
     
    do ios=1,max_output_streams
       if((output_frequency(ios) .gt. 0)) then
          if ((output_start_time(ios) .le. tl%nstep) .and. &
               (output_end_time(ios) .ge. tl%nstep) .and. &
               MODULO(tl%nstep,output_frequency(ios)) .eq. 0) then

             ncnt = sum(interpdata(nets:nete)%n_interp)  ! ncnt not defined if output disabled
             output_varnames=>get_current_varnames(ios)
             if (0==piofs%io_rank) write(*,'(a,i4,a,i1)') &
                  "lat/lon interp movie output: ios=",ios," interpolation type=",&
                  get_interp_parameter("itype")

             start2d(3)=nf_get_frame(ncdf(ios))
             count2d(3)=1
             start3d(4)=nf_get_frame(ncdf(ios))
             count3d(4)=1

             if(nf_selectedvar('ps', output_varnames)) then
                st=1
                allocate (datall(ncnt,1))
                
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
#ifdef _PRIM
#ifdef SPHEREW
                   call interpolate_scalar(interpdata(ie),elem(ie)%state%ps_v(:,:,n0), &
                        np, datall(st:en,1))
#else
                   call interpolate_scalar(interpdata(ie),elem(ie)%state%lnps(:,:,n0), &
                        np, datall(st:en,1))
                   datall(st:en,1)=exp(datall(st:en,1))
#endif
#else
#ifdef _PRIMDG
                   call interpolate_scalar(interpdata(ie),elem(ie)%state%pr3d(:,:,nlev+1), &
                        np, datall(st:en,1))
#else
                   call interpolate_scalar(interpdata(ie),elem(ie)%state%ps, &
                        np, datall(st:en,1))
#endif
#endif
                   st=st+interpdata(ie)%n_interp
                enddo
	        
#ifdef _PRIM
                if (p0 < 2000)  then  ! convert to Pa, if using mb
                   datall(:,1) = 100*(datall(:,1)) 
                endif
#endif
                call nf_put_var(ncdf(ios),datall(:,1),start2d,count2d,name='ps')
                deallocate(datall)
             endif


#ifdef _PRIM
             if(nf_selectedvar('geos', output_varnames)) then
                if (nf_get_frame(ncdf(ios))==1) then
                st=1
                allocate (datall(ncnt,1))
                
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie),elem(ie)%state%phis(:,:), &
                        np, datall(st:en,1))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall(:,1),start2d,count2d,name='geos')
                deallocate(datall)
                endif
             endif
#endif

             if(nf_selectedvar('zeta', output_varnames)) then
                allocate(datall(ncnt,nlev))
                allocate(var3d(nv,nv,nlev,nets:nete))
#ifdef _PRIM
                ! velocities are on sphere for primitive equations
!                call compute_zeta_C0(var3d,elem,hybrid,nets,nete,n0)
                ! debug code:
                call set_interp_parameter("itype",1)
                do ie=nets,nete
                   do k=1,nlev
                      var3d(:,:,k,ie)=elem(ie)%spherev(:,:)%lat
                   enddo
                enddo
#else
                lenscale = rearth

                do ie=nets,nete

                   rdx=2.0D0/(elem(ie)%dx*lenscale) 
                   rdy=2.0D0/(elem(ie)%dy*lenscale)    
                   dx=0.5D0*elem(ie)%dx/lenscale
                   dy=0.5D0*elem(ie)%dy/lenscale
                   
                   do k=1,nlev
                      do j=1,nv
                         do i=1,nv
                            v1  = elem(ie)%state%v(i,j,1,k,n0)
                            v2  = elem(ie)%state%v(i,j,2,k,n0)   
                            vco(i,j,1) = elem(ie)%met(1,1,i,j)*v1 + elem(ie)%met(1,2,i,j)*v2
                            vco(i,j,2) = elem(ie)%met(2,1,i,j)*v1 + elem(ie)%met(2,2,i,j)*v2
                         enddo
                      enddo
                      
                      var3d(:,:,k,ie) = vorticity(vco(1,1,1),deriv,rdx,rdy)
                      
                      do j=1,nv
                         do i=1,nv
                            var3d(i,j,k,ie)=(var3d(i,j,k,ie)/elem(ie)%metdet(i,j))
                         end do
                      end do
                      
                   enddo
                enddo
                ! apply DSS
                call make_C0(var3d,elem,hybrid,nets,nete)
#endif
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), var3d(:,:,:,ie), &
                        nv, nlev, datall(st:en,:),pcord)
                   if (pcord/=0) then
                      print *,'element coords ie=',ie
                      print *,'lat'
                      do ii=1,nv
                      write(*,'(4f20.10)') elem(ie)%spherev(ii,:)%lat
                      enddo
                      print *,'lon'
                      do ii=1,nv
                      write(*,'(4f20.10)') elem(ie)%spherev(ii,:)%lon
                      enddo
                   endif
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='zeta')
                deallocate(datall, var3d)

                call set_interp_parameter("itype",0)
             end if

             if(nf_selectedvar('u', output_varnames) .or. &
                  nf_selectedvar('v', output_varnames)) then
                allocate(var3d(ncnt,2,nlev,1))

                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_vector(interpdata(ie), elem(ie)%Dinv, elem(ie)%FaceNum, &
                        elem(ie)%state%v(:,:,:,:,n0), nv, nlev, var3d(st:en,:,:,1), 0)
                   st=st+interpdata(ie)%n_interp
                enddo

                if(nf_selectedvar('u', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,1,:,1),start3d, count3d, name='u')
                end if

                if(nf_selectedvar('v', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,2,:,1),start3d, count3d, name='v')
                end if
                deallocate(var3d)
             end if

#ifdef _PRIM
             if(nf_selectedvar('ke', output_varnames)) then
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%accum%ke, &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='ke')
                deallocate(datall)
             end if

             if(nf_selectedvar('T', output_varnames)) then
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%state%T(:,:,:,n0), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='T')
                deallocate(datall)
             end if

             if(nf_selectedvar('Th', output_varnames)) then
                pr0=1./(p0)
                st=1
                allocate(datall(ncnt,nlev),var3d(np,np,nlev,1))
                do ie=nets,nete
                   do k=1,nlev
                      do j=1,np
                         do i=1,np
                            pfull = hvcoord%hyam(k)*hvcoord%ps0  &
                                 + hvcoord%hybm(k)*exp(elem(ie)%state%lnps(i,j,n0))
                            var3d(i,j,k,1)=elem(ie)%state%T(i,j,k,n0)* &
                                 (pfull*pr0)**(-kappa)
                         end do
                      end do
                   end do
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), var3d(:,:,:,1), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                end do
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='Th')
                deallocate(datall,var3d)
             end if
             if(nf_selectedvar('Q', output_varnames) .and. qsize>=1) then
                ! switch to bilinear interpolation for tracers
                itype=get_interp_parameter("itype")
                call set_interp_parameter("itype",1)
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%state%Q(:,:,:,1,n0), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='Q')
                deallocate(datall)
                call set_interp_parameter("itype",itype)
             end if
             if(nf_selectedvar('Q2', output_varnames).and. qsize>=2) then
                itype=get_interp_parameter("itype")
                call set_interp_parameter("itype",1)
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%state%Q(:,:,:,2,n0), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='Q2')
                deallocate(datall)
                call set_interp_parameter("itype",itype)
             end if

             if(nf_selectedvar('Q3', output_varnames).and. qsize>=3) then
                itype=get_interp_parameter("itype")
                call set_interp_parameter("itype",1)
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%state%Q(:,:,:,3,n0), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='Q3')
                deallocate(datall)
                call set_interp_parameter("itype",itype)
             end if

             if(nf_selectedvar('Q4', output_varnames).and. qsize>=4) then
                itype=get_interp_parameter("itype")
                call set_interp_parameter("itype",1)
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%state%Q(:,:,:,4,n0), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='Q4')
                deallocate(datall)
                call set_interp_parameter("itype",itype)
             end if

             if(nf_selectedvar('geo', output_varnames)) then
                allocate(datall(ncnt,nlev))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), elem(ie)%state%phi, &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='geo')
                deallocate(datall)
             end if

             if(nf_selectedvar('omega', output_varnames)) then
                allocate(datall(ncnt,nlev), var3d(np,np,nlev,nets:nete))
                do ie=nets,nete
                   do k=1,nlev
                      do j=1,np
                         do i=1,np
                            pfull = hvcoord%hyam(k)*hvcoord%ps0  &
                                 + hvcoord%hybm(k)*exp(elem(ie)%state%lnps(i,j,n0))
                            var3d(i,j,k,ie)=elem(ie)%state%omega_p(i,j,k)*pfull
                         end do
                      end do
                   end do
                end do
                call make_C0(var3d,elem,hybrid,nets,nete)
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_scalar(interpdata(ie), var3d(:,:,:,ie), &
                        np, nlev, datall(st:en,:))
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='omega')
                deallocate(datall,var3d)
             end if

             ! note: this is kind of a hack: forcing is computed during the
             ! timestep, from timelevel nm1 and stored in FM(nm1). after
             ! the timestep is over, nm1 data will be in FM(np1)
             if(nf_selectedvar('FU', output_varnames) .or. &
                  nf_selectedvar('FV', output_varnames)) then
                allocate(var3d(ncnt,2,nlev,1))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_vector(interpdata(ie), elem(ie)%Dinv, elem(ie)%FaceNum, &
                        elem(ie)%state%FM(:,:,:,:,tl%np1), nv, nlev, var3d(st:en,:,:,1), 0)
                   st=st+interpdata(ie)%n_interp
                enddo

                if(nf_selectedvar('FU', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,1,:,1),start3d, count3d, name='FU')
                end if

                if(nf_selectedvar('FV', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,2,:,1),start3d, count3d, name='FV')
                end if
                deallocate(var3d)
             end if

#ifdef ENERGY_DIAGNOSTICS
             if(nf_selectedvar('DIFFU', output_varnames) .or. &
                  nf_selectedvar('DIFFV', output_varnames)) then
                allocate(var3d(ncnt,2,nlev,1))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_vector(interpdata(ie), elem(ie)%Dinv, elem(ie)%FaceNum, &
                        elem(ie)%accum%DIFF(:,:,:,:), nv, nlev, var3d(st:en,:,:,1), 0)
                   st=st+interpdata(ie)%n_interp
                enddo

                if(nf_selectedvar('DIFFU', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,1,:,1),start3d, count3d, name='DIFFU')
                end if

                if(nf_selectedvar('DIFFV', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,2,:,1),start3d, count3d, name='DIFFV')
                end if
                deallocate(var3d)
             end if
             if(nf_selectedvar('CONVU', output_varnames) .or. &
                  nf_selectedvar('CONVV', output_varnames)) then
                allocate(var3d(ncnt,2,nlev,1))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   call interpolate_vector(interpdata(ie), elem(ie)%Dinv, elem(ie)%FaceNum, &
                        elem(ie)%accum%CONV(:,:,:,:), nv, nlev, var3d(st:en,:,:,1), 0)
                   st=st+interpdata(ie)%n_interp
                enddo

                if(nf_selectedvar('CONVU', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,1,:,1),start3d, count3d, name='CONVU')
                end if

                if(nf_selectedvar('CONVV', output_varnames)) then
                   call nf_put_var(ncdf(ios),var3d(:,2,:,1),start3d, count3d, name='CONVV')
                end if
                deallocate(var3d)
             end if
#endif



             if(test_case.eq.'aquaplanet') then
                call aq_movie_output(ncdf(ios), elem, interpdata, output_varnames, ncnt, nlev)
             end if
             if(columnpackage.ne.'none') then
                call physics_movie_output(ncdf(ios),elem, interpdata, output_varnames, ncnt)
             end if
#else
             if(nf_selectedvar('geop', output_varnames)) then
                itype=get_interp_parameter("itype")
                call set_interp_parameter("itype",1)
                allocate(datall(ncnt,nlev),var3d(np,np,nlev,1))
                st=1
                do ie=nets,nete
                   en=st+interpdata(ie)%n_interp
                   do k=1,nlev
                      var3d(:,:,k,1) = (elem(ie)%state%p(:,:,k,n0) + elem(ie)%state%ps(:,:) + phimean)/g
                      call interpolate_scalar(interpdata(ie), var3d(:,:,k,1), &
                           np, datall(st:en,k))
                   end do
                   st=st+interpdata(ie)%n_interp
                enddo
                call nf_put_var(ncdf(ios),datall,start3d, count3d, name='geop')
                deallocate(datall,var3d)
                call set_interp_parameter("itype",itype)
             end if
#endif
             if(piofs%io_rank==0) then
                count2d(3:3)=1
             else
                count2d(3:3)=0
             end if
             call nf_put_var(ncdf(ios),real(dayspersec*time_at(tl%nstep),kind=real_kind),&
                  start2d(3:3),count2d(3:3),name='time')
             call nf_advance_frame(ncdf(ios))
#ifdef PIOSYNC
             call pio_syncfile(ncdf(ios)%fileid)
#endif
          end if ! if output needs to be written
       end if ! output stream is enabled
    end do  ! do ios=1,max_output_streams
    call t_stopf('interp_movie_output')
  end subroutine interp_movie_output





  subroutine GetIODOF(ndims, gdims, iorank, iodof, start, count)
    integer, intent(in) :: gdims(ndims)
    integer, intent(in) :: iorank
    integer(kind=nfsizekind), intent(out) :: start(ndims), count(ndims)
    integer, intent(out), pointer :: iodof(:)

    integer :: nzrank, nxrank, nx, k, i, j, ndims, icnt




    if(iorank>=0) then
       nx=num_io_procs
       count(ndims)=max(1,gdims(ndims)/num_io_procs)
       nx=max(1,num_io_procs/gdims(ndims))
       nzrank=iorank/nx

       k=num_io_procs-gdims(ndims)*nx

       if(iorank>num_io_procs-k-1.and.k>0) then
          nzrank=gdims(ndims)-1
       end if

       start(ndims)=nzrank*count(ndims)+1
       if(gdims(ndims)>num_io_procs) then
          k=gdims(ndims)-num_io_procs*count(ndims)
          if(k>iorank) then
             count(ndims)=count(ndims)+1
          end if
          if(k>=iorank) then
             start(ndims)=start(ndims)+iorank
          else
             start(ndims)=start(ndims)+k
          end if

       end if

       if(k>0 .and.nzrank==gdims(ndims)-1 ) then
          nx=nx+k
       end if
       nxrank=iorank

       do i=ndims-1,1,-1
          !           print *, nxrank, nx

          nxrank=mod(nxrank,nx)
          count(i)=gdims(i)/nx
          k=gdims(i)-count(i)*nx
          if(nxrank<k) then
             count(i)=count(i)+1
             start(i)=count(i)*nxrank+1
          else
             start(i)=count(i)*nxrank+k+1
          end if
          nx=max(1,num_io_procs/gdims(i))

       end do

       icnt=0
       if(ndims.eq.1) then
          allocate(iodof(count(1)))
          do i=1,count(1)
             iodof(i)=start(1)+i-1
          end do
       else if(ndims.eq.2) then
          allocate(iodof(count(1)*count(2)))

          do j=1,count(2)
             do i=1,count(1)
                icnt=icnt+1
                iodof(icnt)=start(1)+gdims(1)*(start(2)-1)+icnt-1
             end do
          end do

       else
          allocate(iodof(count(1)*count(2)*count(3)))

          do k=1,count(3)
             do j=1,count(2)
                do i=1,count(1)
                   icnt=icnt+1
                   iodof(icnt)=start(1)+gdims(1)*(start(2)-1)+ &
                        gdims(1)*gdims(2)*(start(3)-1)+icnt-1
                end do
             end do
          end do
       end if

    else	
       allocate(iodof(1))
       iodof=-1
    end if

  end subroutine GetIODOF






end module interp_movie_mod
